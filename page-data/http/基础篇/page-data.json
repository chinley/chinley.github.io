{"componentChunkName":"component---src-templates-blog-post-js","path":"/http/基础篇/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"e35cfae2-861b-5721-b507-fe15cdfb7135","excerpt":"08 | 键入网址再按下回车，后面究竟发生了什么？ 最简单的浏览器到服务器的流程： 浏览器从地址栏的输入中获得服务器的IP地址和端口号； 浏览器用TCP的三次握手与服务器建立连接； 浏览器向服务器发送拼好的报文； 服务器收到报文后处理请求，同样拼好报文再发给浏览器； 浏览器解析报文，渲染输出页面 HTTP…","html":"<h2>08 | 键入网址再按下回车，后面究竟发生了什么？</h2>\n<p><strong>最简单的浏览器到服务器的流程：</strong></p>\n<ol>\n<li><strong>浏览器从地址栏的输入中获得服务器的IP地址和端口号；</strong></li>\n<li><strong>浏览器用TCP的三次握手与服务器建立连接；</strong></li>\n<li><strong>浏览器向服务器发送拼好的报文；</strong></li>\n<li><strong>服务器收到报文后处理请求，同样拼好报文再发给浏览器；</strong></li>\n<li><strong>浏览器解析报文，渲染输出页面</strong></li>\n</ol>\n<p>HTTP协议基于底层的TCP/IP协议，所以必须要用IP地址建立连接；如果不知道IP地址，就要用DNS协议去解析得到IP地址，否则就会连接失败；</p>\n<p>建立TCP连接后会顺序收发数据，请求方和应答方都必须依据HTTP规范构建和解析报文；</p>\n<p>为了减少响应时间，整个过程中的每一个环节都会有缓存。</p>\n<h4>在浏览器里点击页面连接后发生了什么？</h4>\n<p>浏览器判断这个连接是要在当前页面打开还是新开标签页，接着从地址栏中获取输入的连接的服务器ip地址和端口号。浏览器用三次握手与服务器建立连接，然后向服务器发送拼接好的报文，服务端接受到后同样拼好报文再发给浏览器。浏览器解析报文，渲染输出页面。</p>\n<h4>如果是一个不存在的域名，那么浏览器的工作流程是怎样？</h4>\n<p>浏览器判断是不是IP地址，不是就进行域名解析，依次通过浏览器缓存、系统缓存、host文件，还是没有找的请求DNS服务器获取IP解析（解析失败的浏览器尝试换别的DNS服务器，最终失败的进入错误页面）。有可能获取到CDN服务IP地址，访问CDN先看是否缓存了，缓存了响应用户，无法缓存，缓存失败或者无缓存，回源到服务器。经过防火墙外网网关路由到nginx路由层。ng缓存中存在的直接返回，不存在的负载到web服务器。web服务器接收到请求后处理，路径不存在404.存在的返回结果，cdn加入缓存响应用户。</p>\n<h2>09 | HTTP报文是什么样子的？</h2>\n<h4>报文结构</h4>\n<p>拿TCP报文来举例，它在实际要传输的数据之前附加了一个20字节的头数据，存储TCP协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等。</p>\n<p>有了这个附加的TCP头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据\n<img src=\"https://static001.geekbang.org/resource/image/17/95/174bb72bad50127ac84427a72327f095.png\"></p>\n<p>HTTP协议也是与TCP/UDP类似，不过与其不同的是，它是<strong>纯文本</strong>的协议，所以头部数据都是ASCII码的文本。</p>\n<p>HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>\n<ol>\n<li>起始行：描述请求或响应的基本信息；</li>\n<li>头部的字段集合：使用key-value形式更详细地说明报文；</li>\n<li>消息正文：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>\n</ol>\n<p>HTTP 协议规定报文必须有 header，但可以没有 body，而且在 header 之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。</p>\n<p><img src=\"https://static001.geekbang.org/resource/image/62/3c/62e061618977565c22c2cf09930e1d3c.png\"></p>\n<h4>请求行/起始行</h4>\n<p>简要描述客户端想要如何操作服务器端的资源</p>\n<p>由三部分构成：</p>\n<ol>\n<li>请求方法： 表示对资源的操作，如GET/POST</li>\n<li>请求目标：标记请求方法要操作的资源，通常是一个url</li>\n<li>版本号： 表示报文使用的HTTP协议版本</li>\n</ol>\n<p>通常用空格分割这三部分，最后用CRLF换行表示结束</p>\n<h4>状态行</h4>\n<p>服务器响应的状态</p>\n<ol>\n<li>版本号：标识报文使用的HTTP协议版本；</li>\n<li>状态码</li>\n<li>\n<p>原因</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token constant\">HTTP</span><span class=\"token operator\">/</span><span class=\"token number\">1.1</span> <span class=\"token number\">404</span> Not Found\n<span class=\"token constant\">HTTP</span><span class=\"token operator\">/</span><span class=\"token number\">1.1</span> <span class=\"token number\">200</span> <span class=\"token constant\">OK</span></code></pre></div>\n</li>\n</ol>\n<h4>头部字段</h4>\n<p>请求行或者状态行再加上头部字段集合就构成了HTTP报文里完整的请求头或响应头。</p>\n<p><img src=\"hhttps://static001.geekbang.org/resource/image/1f/ea/1fe4c1121c50abcf571cebd677a8bdea.png\">\n<img src=\"https://static001.geekbang.org/resource/image/cb/75/cb0d1d2c56400fe9c9988ee32842b175.png\"></p>\n<p>如果拼 HTTP 报文的时候，在头字段后多加了一个 CRLF，导致出现了一个空行，会发生什么？</p>\n<p>空行后的数据当作body返回</p>\n<p>讲头字段时说“:”后的空格可以有多个，那为什么绝大多数情况下都只使用一个空格呢？</p>\n<p>节省资源</p>\n<h2>10 | 应该如何理解请求方法？</h2>\n<h4>标准请求方法</h4>\n<ol>\n<li>GET</li>\n<li>HEAD: 获取资源的元信息</li>\n<li>POST: 向资源提交数据，相当于写入或上传数据</li>\n<li>PUT</li>\n<li>DELETE</li>\n<li>CONNECT: 建立特殊的连接隧道；</li>\n<li>OPTIONS: 列出可对资源实行的方法；</li>\n<li>TRACE：追求请求 - 响应的传输路径</li>\n</ol>\n<h4>GET/HEAD</h4>\n<p>HEAD与GET类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，<strong>只会传回响应头，也就是资源的元信息</strong></p>\n<h4>POST/PUT</h4>\n<p> POST通常表示是“新建”，PUT是“修改”</p>\n<h4>其他方法</h4>\n<p><strong>DELETE</strong>删除服务器资源</p>\n<p><strong>CONNECT</strong>，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时web服务器在中间充当代理的角色</p>\n<p><strong>OPTIONS</strong>方法要求服务器列出可对资源实行的操作方法，在响应头的Allow字段里返回</p>\n<p><strong>TRACE</strong>多用于对HTTP链路的测试或诊断，可以显示出请求-响应的传输路径。但存在漏洞，会泄漏网站信息，web服务器通常是禁止使用</p>\n<h2>12 | 响应状态码该怎么用？</h2>\n<h4>状态码</h4>\n<ul>\n<li>1xx：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>\n<li>2xx: 成功，报文已经收到并被正确处理</li>\n<li>3xx: 重定向，资源位置发生变动，需要客户端重新发送请求</li>\n<li>4xx: 客户端错误，请求报文有误，服务器无法处理</li>\n<li>5xx: 服务器错误，服务器在处理请求时内部发生了错误</li>\n</ul>\n<h4>1xx</h4>\n<p> 1xx类状态是属于提示信息，提示当前协议处理处于中间状态</p>\n<p> <strong>101 Switching Protocols</strong>, 意思是客户端使用Uprade头字段，要求在http协议的基础上改成其他协议以继续通信，比如websocket。而如果服务端也同意变更，就会发送101状态码。但这之后的数据传输就不会再用http</p>\n<h4>2xx</h4>\n<p>  <strong>200 ok</strong></p>\n<p>  <strong>204 No Content</strong>，响应头后没有body数据</p>\n<p>  <strong>206 Partial Content</strong>是http分块下载或断点传续的基础，在客户端发送请求获取资源的部分数据出现，<strong>但body里的数据不是资源的全部，而是其中的一部分</strong></p>\n<p>  206状态还伴随<strong>Content-Range</strong>头字段，表示响应报文里body数据的具体范围，供客户端确认。例如Content-Range：bytes 0-99/2000, 此次获取的是总计2000个字节的前100个字节</p>\n<h4>3xx</h4>\n<p>  表示客户端请求的资源发生了变动。客户端必须用新的URI重新发送请求获取资源，也就是通常说的重定向</p>\n<p>  <strong>301 Moved Permanently</strong>永久重定向，此次请求的资源已经不再了，需要改用新的URI访问</p>\n<p>  <strong>302 Fond</strong> 临时重定向，请求的资源还在，但暂时需要用另一个URI访问。</p>\n<p>  301 302都会在响应头里使用Location字段指明后续要跳转的URI。</p>\n<p>  <strong>304 Not Modified</strong>,用于If-Modified-Since等条件请求，表示资源未修改，用于缓存控制。“重定向到已缓存文件”</p>\n<h4>4xx</h4>\n<p>  表示客户端发送的请求报文有误，服务器无法处理</p>\n<p>  <strong>400 Bad Request</strong>通用错误码，表示请求报文有错误</p>\n<p>  <strong>403 Forbidden</strong>表示服务器禁止访问资源</p>\n<p>  <strong>404 Not Found</strong>表示资源在服务器上未找到，所以无法提供给客户端</p>\n<p>  <strong>405 Method Not Allowed</strong>: 不允许使用某些方法操作资源，例如不能post只能get</p>\n<h4>5xx</h4>\n<p>  表示客户端请求报文正确，但服务器在处理内部发生了错误，无法返回应有的响应数据，是服务器端的错误码</p>\n<p>  <strong>500 Internal Server Eroor</strong>通用错误码</p>\n<p>  <strong>501 Not Implemented</strong>表示客户端请求的功能还不支持</p>\n<p>  <strong>502 Bad GateWay</strong>服务器作为<strong>网关或代理</strong>时返回的错误码</p>\n<p>  <strong>503 Service Unavailable</strong>服务器当前很忙，暂时无法响应服务。503响应报文通常还会有一个<strong>Retry-After</strong>字段，指客户端可以在多久以后再次尝试发送请求</p>\n<h2>13 | HTTP有哪些特点？</h2>\n<h4>灵活可扩张</h4>\n<p>  HTTP最初诞生只规定了报文的基本格式，比如用空格分割单词等，报文里各个组成部分没有做严格的语法语义限制</p>\n<h4>可靠传输</h4>\n<p>  HTTP协议基于TCP/IP，而TCP本身是一个“可靠”的传输协议</p>\n<h4>应用层协议</h4>\n<p>  有很多应用层协议，但他们都关注很小的应用领域，例如FTP只传输文件、SMTP只能发送邮件、SSH只能远程登录。</p>\n<h4>请求-应答</h4>\n<p>  请求-应答模式是HTTP协议最根本的通信模型，一发一收，有来有去。</p>\n<h4>无状态</h4>\n<p>  <strong>HTTP协议是无状态</strong></p>\n<p>  “状态”就是客户端或者服务器端里保存的一些数据或者标志，记录了通信过程中的一些变化信息。</p>\n<p>  TCP是有状态，一开始处于CLOSED状态，连接成功后是ESTABLISHED状态，断开连接后是FIN-WAIT状态，最后又是CLOSED状态。</p>\n<p>  “状态”就需要在TCP在内部用一些数据结构去维护。而HTTP在整个协议里没有规定任何的“状态”。客户端和服务器永远是在一种“无知”的状态。建立连接前两者互不知情，每次收发报文也都是相互独立的，没有任何的联系</p>","frontmatter":{"title":"透视HTTP协议","date":"May 29, 2022","description":"课程学习笔记8-14讲"}},"previous":{"fields":{"slug":"/foundamention/html/web安全/"},"frontmatter":{"title":"CSRF与XSS"}},"next":{"fields":{"slug":"/foundamention/react/调度/"},"frontmatter":{"title":"React调度"}}},"pageContext":{"id":"e35cfae2-861b-5721-b507-fe15cdfb7135","previousPostId":"61f9c345-f9e2-5f00-9e2a-9419a6cc482e","nextPostId":"93123f7c-2bd5-5901-9af4-30af5b060234"}},"staticQueryHashes":["2841359383","788015585"]}