{"componentChunkName":"component---src-templates-blog-post-js","path":"/foundamention/react/hooks相关/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"9e22ed81-35ae-5461-a348-11a5c680c9cd","excerpt":"react hooks 相关阅读 「react进阶」一文吃透react-hooks原理 https://juejin.cn/post/6944863057000529933 为什么需要react hooks 在react hooks…","html":"<h4>react hooks</h4>\n<h6>相关阅读</h6>\n<p>「react进阶」一文吃透react-hooks原理</p>\n<p><a href=\"https://juejin.cn/post/6944863057000529933\">https://juejin.cn/post/6944863057000529933</a></p>\n<h5>为什么需要react hooks</h5>\n<ol>\n<li>在react hooks之前，类组件难以共享组件中与状态相关的逻辑，高阶组件学习成本高、组合方式为嵌套，可能props相互覆盖，嵌套地狱</li>\n<li>this绑定混乱</li>\n<li>逻辑复杂的类组件会变的难以开发和维护</li>\n<li>类组件到处都是对状态的访问和处理，导致组件难以拆分</li>\n<li>在生命周期中混杂不想干的逻辑</li>\n</ol>\n<h5>hook如何解决上述问题</h5>\n<ol>\n<li>通过一个hook函数封装跟状态有关的逻辑,将逻辑从组件中抽离出来</li>\n<li>函数组件没有this相关问题</li>\n<li>不同数据处理逻辑/不同副作用可以单独用一个useEffect实现</li>\n</ol>\n<h5>相关QA</h5>\n<ol>\n<li>在无状态组件每一次函数上下执行的时候，react用什么方式记录了hooks的状态\n1.1 循环链表</li>\n<li>多个react-hooks用什么来记录每一个hooks的顺序？为什么不能在条件语句中声明hooks？hooks声明为什么在组件的最顶部</li>\n<li>function函数组件中的useState，和class类组件的setState有什么区别\n3.1 函数组件的useState, setState时直接替换原数据， 类组件会合并对象数据\n3.2</li>\n<li>react是怎么捕获hooks的执行上下文，是在函数组件内部？</li>\n<li>为什么useRef不需要依赖注入，就能访问到最新改变值</li>\n<li>useMemo是怎么对值做缓存，如果应用它优化性能</li>\n<li>为什么两次传入useState的值相同，函数组件不更新</li>\n</ol>\n<p>  current fiber树： 当完成一次渲染之后，会产生一个current树，current会在commit阶段替换成真实的dom树。\n当前屏幕上显示内容对应的fiber树称为current fiber树。</p>\n<p>  workInProgress fiber树：即将调和渲染的fiber树。再一次新的组件更新过程中，会从current复制一份作为workInprogress，更新完毕之后，将当前的workInProgress树赋值给current树。正在内存中构建的fiber树称为workInprogress树，反映了要刷新到屏幕的未来状态。 </p>\n<p>  workInProgress.memoizedState: 在class组件中，memoizedState存放state信息，在function组件中，memoizedState在一次调和渲染过程中，以链表的形式存放hooks信息</p>\n<p>  currentHook: current树上的指向当前调度的hooks节点\nworkInProgressHook: 可以理解workInProgress树上指向的当前调度的hooks节点</p>\n<h4>renderWithHooks函数：</h4>\n<ol>\n<li>首先先制空workInProgress树的memoizedState和updateQueue。</li>\n<li>通过current树上是否有memoizedState信息来判断是否第一次渲染，第一次渲染组件，用的是HooksDispatcherOnMount hooks对象。渲染后，需要更新的函数组件，用的是HooksDispatcherOnUpdate hooks对象。</li>\n<li>调用Component(props, secondArg)执行函数组件，hooks被依次执行，把hooks信息依次保存到workInProgress树上。</li>\n<li>重新置空一些变量</li>\n</ol>\n<p>  <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adcbd09984f84d0d97a15df124e83c09~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"hw-os-app\"></p>\n<h4>hooks初始化，做了什么</h4>\n<h5>1.mountWorkInProgressHook</h5>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">  <span class=\"token keyword\">function</span> <span class=\"token function\">mountWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> hook<span class=\"token operator\">:</span> Hook <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      memoizedState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// useState中 保存 state信息 ｜ useEffect 中 保存着 effect 对象 ｜ useMemo 中 保存的是缓存的值和deps ｜ useRef中保存的是ref 对象</span>\n      baseState<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n      baseQueue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n      queue<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n      next<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgressHook <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">// 例子中的第一个`hooks`-> useState(0) 走的就是这样。</span>\n      currentlyRenderingFiber<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> workInProgressHook <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      workInProgressHook <span class=\"token operator\">=</span> workInProgressHook<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> workInProgressHook<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>  mountWorkInProgressHook函数每次执行一个hooks函数，都产生一个hook对象，里面保存当前hook信息，然后将每个hooks以链表的形式串联起来，并赋值给workInProgress的memoizedState。</p>\n<p>  memoizedState: useState保存state信息｜useEffect保存effect对象｜useMemo保存缓存的值和deps|useRef保存的是ref对象</p>\n<p>  baseQueue: useState和useReducer中保存最新的更新队列</p>\n<p>  baseState: useState和useReducer中，一次更新里产生的最新state值</p>\n<p>  queue: 保存待更新队列pendingQueue，更新函数dispatch等信息</p>\n<p>  next: 指向下一个hooks</p>\n<p>  <img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5660f1be680140239a8cf4e34cfccc90~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.png\" alt=\"hw-os-app\"></p>\n<p>  hooks通过什么来证明唯一性： 通过hooks链表顺序，因此不能在条件语句中声明hooks,<strong>一旦在条件语句中声明hooks，下一次组件更新，hooks链表结构被破坏，current树的memoziedState缓存Hooks信息，和当前workInProgress不一致。如果涉及到读取state等操作，就会发生异常</strong></p>\n<h5>2. 初始化useState -> mountState mountState做了什么</h5>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">mountState</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">initialState</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">mountWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> initialState <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 如果 useState 第一个参数为函数，执行函数得到state</span>\n    initialState <span class=\"token operator\">=</span> <span class=\"token function\">initialState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>baseState <span class=\"token operator\">=</span> initialState<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>hook<span class=\"token punctuation\">.</span>queue <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    pending<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\">// 带更新的</span>\n    dispatch<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">// 负责更新函数</span>\n    lastRenderedReducer<span class=\"token operator\">:</span> basicStateReducer<span class=\"token punctuation\">,</span> <span class=\"token comment\">//用于得到最新的 state ,</span>\n    lastRenderedState<span class=\"token operator\">:</span> initialState<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 最后一次得到的 state</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> dispatch <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">.</span>dispatch <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token function\">dispatchAction</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span> <span class=\"token comment\">// 负责更新的函数</span>\n    <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    currentlyRenderingFiber<span class=\"token punctuation\">,</span>\n    queue<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">,</span> dispatch<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>  mountState执行：首先得到初始化state，将它赋值给mountWorkInProgressHook产生的hook对象的memoizedState和baseState属性。创建queue对象，保存负责更新的信息。</p>\n<h6>dispatchAction是什么</h6>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> dispatchAction<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span><span class=\"token constant\">A</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span>\n  fiber<span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  queue<span class=\"token operator\">:</span> UpdateQueue<span class=\"token operator\">&lt;</span><span class=\"token constant\">S</span><span class=\"token punctuation\">,</span><span class=\"token constant\">A</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  action<span class=\"token operator\">:</span> <span class=\"token constant\">A</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>number<span class=\"token punctuation\">,</span> setNumber<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>  dispatchAction就是<strong>setNumber</strong>，dispatchAction第一个参数和第二个参数，已经被bind给改成currentRenderingFiber和queue,传入的参数是第三个参数action.</p>\n<h5>dispatchAction 无状态组件更新机制</h5>\n<p>  dispatchAction首先产生一个update对象，里面记录此次更新的信息，将此update放入待更新的pending队列中。dispatchAction第二步就是判断当前函数组件的fiber对象是否处于渲染阶段，如果处于渲染阶段，就不需要更新当前函数组件，只需要更新update的expirationTime。</p>\n<p>  如果当前fiber没有处于更新阶段，那么通过调用lastRenderedReducer获取最新的state，和上一次currentState进行浅比较，如果相等就退出。</p>\n<p>  如果两次state不相等，调用scheduleUpdateOnFiber调度渲染当前fiber。scheduleUpdateOnFiber是react渲染更新的主要函数。</p>\n<h5>3. 初始化useEffect -> mountEffect</h5>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">mountEffect</span><span class=\"token punctuation\">(</span>\n  <span class=\"token parameter\">create<span class=\"token punctuation\">,</span>\n  deps<span class=\"token punctuation\">,</span></span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">mountWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> nextDeps <span class=\"token operator\">=</span> deps <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> deps<span class=\"token punctuation\">;</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token function\">pushEffect</span><span class=\"token punctuation\">(</span>\n    HookHasEffect <span class=\"token operator\">|</span> hookEffectTag<span class=\"token punctuation\">,</span> \n    create<span class=\"token punctuation\">,</span> <span class=\"token comment\">// useEffect 第一次参数，就是副作用函数</span>\n    <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">,</span>\n    nextDeps<span class=\"token punctuation\">,</span> <span class=\"token comment\">// useEffect 第二次参数，deps</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>  每个hooks初始化都会创建一个hook对象，然后将hook的memoizedState保存当前effect hook信息。</p>\n<p>  两种memoizedState</p>\n<ul>\n<li>workInProgress / current 树上的memoizedState保存的是当前函数组件每个hooks形成的链表</li>\n<li>每个hooks上的memoizedState保存当前hooks信息，不同种类的hooks的memoizedState内容不同。</li>\n</ul>","frontmatter":{"title":"react hooks","date":"March 31, 2022","description":"笔记-- 「一文吃透react-hooks原理」"}},"previous":{"fields":{"slug":"/foundamention/call和apply/"},"frontmatter":{"title":"js深入之call和apply的模拟实现"}},"next":{"fields":{"slug":"/http/发展史/"},"frontmatter":{"title":"http发展史"}}},"pageContext":{"id":"9e22ed81-35ae-5461-a348-11a5c680c9cd","previousPostId":"ecbaa1cb-7843-5359-b4f7-2462ec170b66","nextPostId":"5ef73e7a-810f-5450-bb46-bfe092644061"}},"staticQueryHashes":["2841359383","788015585"]}