{"componentChunkName":"component---src-templates-blog-post-js","path":"/foundamention/react/渲染流程/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"7658b6e1-bf53-540d-a7c4-347dcf5499db","excerpt":"在梳理之前，先来了解渲染流程中一个概念---协调 协调（Reconciler）   React 官方文档在对于协调的解释 React 提供的声明式 API 让开发者可以在对 React…","html":"<p>在梳理之前，先来了解渲染流程中一个概念---协调</p>\n<h4>协调（Reconciler）</h4>\n<p>  React 官方文档在对于协调的解释</p>\n<blockquote>\n<p>React 提供的声明式 API 让开发者可以在对 React 的底层实现没有具体了解的情况下编写应用。在开发者编写应用时虽然保持相对简单的心智，但开发者无法了解内部的实现机制。本文描述了在实现 React 的 “diffing” 算法中我们做出的设计决策以保证组件满足更新具有可预测性，以及在繁杂业务下依然保持应用的高性能性。</p>\n</blockquote>\n<p>  Reconciler是协助React确认状态变化时要更新哪些Dom元素的diff算法。</p>\n<p>  Reconciler模块以React 16为分界线分为两个版本：</p>\n<ul>\n<li>Stack Reconciler是React 15及以前版本的渲染方案，其核心是以<strong>递归的方式</strong>逐级调度栈中子节点到父节点的渲染，无法中断</li>\n<li>Fiber Reconciler是React 16以后版本的渲染方案，核心设计是<strong>增量渲染</strong>，将渲染工作分割为多个区块，并将其分散到多个帧中去执行。设计初衷是提高React在动画、画布及手势等场景下的性能表现。基于循环遍历diff</li>\n</ul>\n<p>  两者渲染的性能差距示例： <a href=\"https://claudiopro.github.io/react-fiber-vs-stack-demo/\">https://claudiopro.github.io/react-fiber-vs-stack-demo/</a></p>\n<h4>渲染</h4>\n<h5>Stack Reconciler</h5>\n<p>  Stack Reconciler 没有单独的包，并没有像 Fiber Reconclier 一样抽取为独立的包</p>\n<p>  堆</p>","frontmatter":{"title":"如何解释 React 的渲染流程","date":"June 19, 2022","description":null}},"previous":{"fields":{"slug":"/foundamention/react/JSX/"},"frontmatter":{"title":"为什么React要用JSX"}},"next":{"fields":{"slug":"/leetcode/岛屿问题/"},"frontmatter":{"title":"岛屿类问题的通用解法"}}},"pageContext":{"id":"7658b6e1-bf53-540d-a7c4-347dcf5499db","previousPostId":"8a0bebea-b828-5381-8493-e61b92f044d7","nextPostId":"d2161470-6640-54e4-b01b-c85a2ad6be0b"}},"staticQueryHashes":["2841359383","788015585"]}