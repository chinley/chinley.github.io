{"componentChunkName":"component---src-templates-blog-post-js","path":"/foundamention/react/合成事件/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"a77b3079-e732-56a2-a1c1-e5d2e5d19a46","excerpt":"合成事件   合成事件的触发基于浏览器的事件机制，通过冒泡机制冒泡到最顶层元素，然后再由dispatchEvent统一处理 浏览器事件机制   捕获阶段（父到子） -> 获取到目标元素 -> 冒泡阶段（子到父）\n  Q:若对合成事件进行阻止，原生事件是否会执行。会\n  A…","html":"<h4>合成事件</h4>\n<p>  合成事件的触发基于浏览器的事件机制，通过冒泡机制冒泡到最顶层元素，然后再由dispatchEvent统一处理</p>\n<h4>浏览器事件机制</h4>\n<p>  捕获阶段（父到子） -> 获取到目标元素 -> 冒泡阶段（子到父）\nQ:若对合成事件进行阻止，原生事件是否会执行。会\nA:因为原生事件优先于合成事件执行。而合成事件处于目标阶段，它阻止的冒泡只是阻止合成的事件冒泡，但是原生事件在捕获阶段就已经执行了</p>\n<h4>合成事件特点</h4>\n<ol>\n<li>React上注册的事件最终会绑定在根结点上(react 17是根结点，之前是在document上)，而不是组件对应的dom。</li>\n<li>React自身实现了一套事件冒泡机制，因此e.stoppropagation无效</li>\n<li>React通过对象池的形式管理合成事件对象的创建和销毁，减少垃圾的生成和新对象内存的分配</li>\n</ol>\n<h4>React事件机制</h4>\n<p>  事件注册、事件存储、事件分发、事件执行（构造合成事件、批处理）</p>\n<h4>为什么需要合成事件</h4>\n<ol>\n<li>统一浏览器的各个标准，兼容多个浏览器的事件，在底层抹平不同浏览器的差异</li>\n<li>对合成事件中的调用的setstate进行合并，避免多次更新造成浪费</li>\n<li>更好的实现事件管控，以便契合react自身的一些策略和优化</li>\n</ol>","frontmatter":{"title":"React之合成事件","date":"February 22, 2022","description":null}},"previous":{"fields":{"slug":"/foundamention/闭包/"},"frontmatter":{"title":"JS深入之闭包"}},"next":{"fields":{"slug":"/foundamention/react/fiber/"},"frontmatter":{"title":"React之about fiber"}}},"pageContext":{"id":"a77b3079-e732-56a2-a1c1-e5d2e5d19a46","previousPostId":"b64c0007-3658-5f9b-a020-3ba1d09393d3","nextPostId":"60546cf2-65b3-5602-ab93-bdb589ea5d60"}},"staticQueryHashes":["2841359383","788015585"]}