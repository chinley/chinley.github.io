{"componentChunkName":"component---src-templates-blog-post-js","path":"/foundamention/作用域/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"64b4d2ff-68e8-5d34-a67b-204587879ef8","excerpt":"文章导读 https://github.com/mqyqingfeng/Blog/issues/3 静态作用域vs动态作用域 JavaScript采用词法作用域，也就是静态作用域。\n词法作用域：函数的作用域在函数定义的时候就决定了\n动态作用域：函数的作用域在函数调用的时候才决定 什么是变量提升   var…","html":"<h5>文章导读</h5>\n<p><a href=\"https://github.com/mqyqingfeng/Blog/issues/3\">https://github.com/mqyqingfeng/Blog/issues/3</a></p>\n<h4>静态作用域vs动态作用域</h4>\n<p>JavaScript采用词法作用域，也就是静态作用域。\n词法作用域：函数的作用域在函数定义的时候就决定了\n动态作用域：函数的作用域在函数调用的时候才决定</p>\n<h4>什么是变量提升</h4>\n<p>  var变量会发生“变量提升”的现象，即变量可以在声明之前使用，值为undefined。let/const声明变量的一定要在声明之后使用，否则报错。</p>\n<h4>为什么存在变量提升</h4>\n<p>  主要是因为在执行上下文创建阶段，函数声明和var声明的变量已经被赋予了一个值，var声明被设置了undefined，函数声明为自身，let 和 const 设置为未初始化。作用域创建时两者初始化的值不同。</p>\n<h4>暂时性死区</h4>\n<p>  在代码块内，使用let/const声明变量之前，该变量都是不可用的。本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取。只有执行到声明变量，才可以获取和使用该变量。</p>\n<h4>什么是作用域链</h4>\n<p>  当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级执行上下文的变量对象中查找，一直到全局上下文的变量对象，也就是全局对象。这种由多个执行上下文的变量对象构成的链表叫做作用域链。</p>","frontmatter":{"title":"js深入之词法作用域和动态作用域","date":"February 08, 2022","description":"读书笔记"}},"previous":{"fields":{"slug":"/foundamention/原型与原型链/"},"frontmatter":{"title":"js深入之从原型到原型链"}},"next":{"fields":{"slug":"/foundamention/变量对象/"},"frontmatter":{"title":"js深入之变量对象"}}},"pageContext":{"id":"64b4d2ff-68e8-5d34-a67b-204587879ef8","previousPostId":"3101eea9-8667-599d-8075-762084005520","nextPostId":"5b0faae5-1cef-5617-ac4b-59c7d864ff75"}},"staticQueryHashes":["2841359383","788015585"]}