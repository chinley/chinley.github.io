{"componentChunkName":"component---src-templates-blog-post-js","path":"/longest/path/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"a50e3ba5-2acb-5021-bcf8-2839a8d8f7bc","excerpt":"问题描述   一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。   机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。   问总共有多少条不同的路径？   hw-os-app   输入：m = 3, n = 7   输出：2…","html":"<h3>问题描述</h3>\n<p>  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>  机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n<p>  问总共有多少条不同的路径？</p>\n<p>  <img src=\"https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png\" alt=\"hw-os-app\"></p>\n<p>  输入：m = 3, n = 7</p>\n<p>  输出：28</p>\n<h3>做题思路</h3>\n<p>  给定终点，不同方向不同路径，或者每步步数不定，典型的动态规划题目</p>\n<p>  动态规划三要素：1.重叠子问题 2.最优子结构 3.状态转移方程</p>\n<ol>\n<li>重叠子问题\n走到（m,n)位置的路径，由走到（m, n-1)路径数量和走到（m-1，n)路径数量组成</li>\n<li>最优子结构</li>\n<li>状态转移方程</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">f(m,n)=f(m−1,n)+f(m,n−1)\n\nf(i, 0) = 1, i &lt; m\n\nf(0, j) = 1, j &lt; n</code></pre></div>\n<h3>code</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> var uniquePaths = function(m, n) {\n  const arr = [];\n  for(let i = 0; i &lt; m; i++) {\n      arr[i] = [];\n      arr[i][0] = 1;\n  }\n  for(let j = 0; j&lt;n; j++) {\n      arr[0][j] = 1;\n  }\n  for(let i=1;i&lt;m;i++) {\n      for(let j=1;j&lt;n;j++) {\n          arr[i][j] = arr[i-1][j] + arr[i][j-1];\n      }\n  }\n\n  return arr[m-1][n-1];\n};</code></pre></div>\n<h3>延伸题</h3>\n<h4>不同路径 II</h4>\n<p>  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>\n<p>  机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>\n<p>  现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n<p>  <img src=\"https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg\" alt=\"hw-os-app\"></p>\n<p>  解题思路： 当有0时把当前点置0，边界中若f(i,0)有障碍，则 i&#x3C; j &#x3C; m都要置0</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var uniquePathsWithObstacles = function(obstacleGrid) {\n  const n = obstacleGrid.length, m = obstacleGrid[0].length;\n  const arr = createArray(m,n);\n  arr[0][0] = obstacleGrid[0][0] ? 0 : 1;\n  for(let i= 1;i&lt;m;i++) {\n      arr[0][i] = obstacleGrid[0][i] === 1 ? 0 : arr[0][i-1];\n  }\n\n  for(let j=1;j&lt;n;j++) {\n      arr[j][0] = obstacleGrid[j][0] === 1 ? 0 : arr[j-1][0];\n  }\n  for(let i = 1; i&lt; m; i++) {\n      for(let j=1;j&lt;n;j++) {\n          arr[j][i] = obstacleGrid[j][i] === 1 ? 0 : arr[j-1][i] + arr[j][i-1];\n      }\n  }\n  return arr[n-1][m-1];\n};\n\nfunction createArray(m,n) {\n  return new Array(n).fill(&#39;&#39;).map(() =&gt; new Array(m).fill(0));\n}</code></pre></div>\n<h4>路径最小和</h4>\n<p>  给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>\n<p>  说明：每次只能向下或者向右移动一步。</p>\n<p>  <img src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" alt=\"hw-os-app\"></p>\n<p>  输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</p>\n<p>  输出：7</p>\n<p>  解释：因为路径 1→3→1→1→1 的总和最小。</p>\n<p>  把（m,n)上的数字表示成a(m,n),路径(m,n)上数字最小和为Sum(m,n)</p>\n<p>  Sum(m,n) = Math.min(Sum(m-1,n), Sum(m, n-1)) + a(m,n)</p>\n<p>  表中的数据把路径之和替换为路径的最小数</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  var minPathSum = function(grid) {\n    const n = grid.length, m = grid[0].length;\n    const arr = createArray(m,n);\n    arr[0][0] = grid[0][0];\n    for(let i = 1; i &lt; m; i++) {\n        arr[0][i] = arr[0][i-1] + grid[0][i];\n    }\n\n    for(let j = 1; j &lt; n; j++) {\n        arr[j][0] = arr[j-1][0] + grid[j][0];\n    }\n\n    for(let i = 1; i&lt;m; i++) {\n        for(let j =1; j&lt;n;j++) {\n            arr[j][i] = grid[j][i] + Math.min(arr[j][i-1], arr[j-1][i]);\n        }\n    }\n    \n    return arr[n-1][m-1];\n};\n\nfunction createArray(m,n) {\n    return new Array(n).fill(&#39;&#39;).map(()=&gt;new Array(m).fill(0));\n}</code></pre></div>","frontmatter":{"title":"路径问题","date":"August 01, 2021","description":"算法题：不同路径"}},"previous":{"fields":{"slug":"/npm/"},"frontmatter":{"title":"前端基础建设与架构"}},"next":null},"pageContext":{"id":"a50e3ba5-2acb-5021-bcf8-2839a8d8f7bc","previousPostId":"e5936b24-44a3-5283-9411-317ca2473607","nextPostId":null}},"staticQueryHashes":["2841359383","788015585"]}