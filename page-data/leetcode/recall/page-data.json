{"componentChunkName":"component---src-templates-blog-post-js","path":"/leetcode/recall/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"98136373-37e3-5a3c-9b75-e958d0634182","excerpt":"回溯涉及到的类型：组合：给定几个数字，返回所有组合， 切割：一个字符串做分割， 子集、排列、棋盘   所有的回溯法都可以抽象为一个树形结构 组合题 17. 电话号码的字母组合   给定一个仅包含数字 2-…","html":"<p>  回溯涉及到的类型：组合：给定几个数字，返回所有组合， 切割：一个字符串做分割， 子集、排列、棋盘</p>\n<p>  所有的回溯法都可以抽象为一个树形结构</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function backtrack() {\n  if(终止条件) {\n    收集结果;\n    return;\n  }\n  for(集合元素) {\n    处理节点;\n    递归函数;\n    回溯\n  }\n}</code></pre></div>\n<h3>组合题</h3>\n<h4>17. 电话号码的字母组合</h4>\n<p>  给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>\n<p>  给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>\n<p>  <img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png\" alt=\"hw-os-app\"></p>\n<p>  输入：digits = “23”</p>\n<p>  输出：[“ad”,“ae”,“af”,“bd”,“be”,“bf”,“cd”,“ce”,“cf”]</p>\n<p>  解题思路：</p>\n<ol>\n<li>画树状图，初始化path，作为每个叶子节点结果，res保存结果，index为遍历的深度</li>\n<li>每次遍历path添加字母，遍历完回溯path回退，当index === digits.length时保存结果</li>\n</ol>\n<h5>code</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var letterCombinations = function(digits) {\n    const digitalMap = {\n        2: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],\n        3: [&quot;d&quot;,&quot;e&quot;,&quot;f&quot;],\n        4: [&quot;g&quot;, &quot;h&quot;, &quot;i&quot;],\n        5: [&quot;j&quot;, &quot;k&quot;, &quot;l&quot;],\n        6: [&quot;m&quot;, &quot;n&quot;, &quot;o&quot;],\n        7: [&quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;],\n        8: [&quot;t&quot;, &quot;u&quot;, &quot;v&quot;],\n        9: [&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;]\n    }\n    const digitsArray = digits.split(&quot;&quot;);\n    const res = [], path = [];\n    if(digits.length === 0) return res;\n    const backtrack = (path, index) =&gt; {\n        if(index === digits.length) {\n            res.push(path.join(&#39;&#39;));\n            return;\n        }\n        const curDigits = digitalMap[digitsArray[index]];\n        for(let i = 0; i &lt; curDigits.length; i++) {\n            path.push(curDigits[i]);\n            backtrack(path, index + 1);\n            path.pop();\n        }\n    }\n    backtrack(path, 0);\n    console.log(res);\n    return res;\n};</code></pre></div>\n<h4>39. 组合总和</h4>\n<p>  给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p>\n<p>  candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p>\n<p>  对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p>\n<p>  输入: candidates = [2,3,6,7], target = 7</p>\n<p>  输出: [[7],[2,2,3]]</p>\n<h4>code</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var combinationSum = function(candidates, target) {\n  const res = [];\n  const backtrack = (path, index) =&gt; {\n      const curSum = path.reduce((pre, cur) =&gt; { return pre + cur;}, 0);\n      if(curSum &gt; target || index === candidates.length) return;\n      if(curSum === target) { \n          res.push([...path]); // res.push(path)，res会跟随path变化，因此需要扩展运算符\n          return;\n      }\n      for(let i = index; i&lt;candidates.length;i++) { //下一次从i的地方开始遍历\n          path.push(candidates[i]);\n          backtrack(path, i); //下一次从i的地方开始遍历\n          path.pop();\n      }\n  }\n  backtrack([], 0);\n  return res;\n};</code></pre></div>\n<h4>46. 全排列</h4>\n<p>  给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>\n<p>  输入：nums = [1,2,3]</p>\n<p>  输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>\n<h5>code</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var permute = function(nums) {\n  const res = [];\n\n  const backtrack = (path, index) =&gt; {\n      if(path.length === nums.length){\n          res.push([...path]);\n          return;\n      }\n      for(let i=0;i&lt;nums.length;i++) {\n          if(path.includes(nums[i])) { // 当已存在这个数字，跳过\n              continue;\n          }\n          path.push(nums[i]);\n          backtrack(path);\n          path.pop();\n      }\n  }\n  backtrack([]);\n  console.log(res);\n  return res;\n};</code></pre></div>\n<h4>22. 括号生成</h4>\n<p>  数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>\n<p>  输入：n = 3</p>\n<p>  输出：[”((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p>\n<p>  解题思路：</p>\n<ol>\n<li>确定终止条件：当(和)数量等于n时，收集结果</li>\n<li>当字符串）比（数量多时，无效括号，需要剪枝</li>\n</ol>\n<h5>code</h5>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var generateParenthesis = function(n) {\n  const res = [];\n  const backtrack = (lRemaind, rRemaind, str) =&gt; {\n      if(lRemaind === 0 &amp;&amp; rRemaind===0) {\n          res.push(str);\n      }\n      if(lRemaind &gt; rRemaind) { // 如果剩余的（比）多，无效分枝，剪枝\n          return;\n      }\n\n      if(lRemaind&gt;0) {\n          backtrack(lRemaind-1,rRemaind, str + &#39;(&#39;);\n      }\n\n      if(rRemaind &gt; lRemaind) {\n          backtrack(lRemaind,rRemaind - 1, str + &#39;)&#39;);\n      }\n  }\n  backtrack(n,n,&#39;&#39;);\n  return res;\n};</code></pre></div>\n<h3>78. 子集</h3>\n<p>  给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p>\n<p>  解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p>\n<p>  输入：nums = [1,2,3]</p>\n<p>  输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p>\n<h4>code</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var subsets = function(nums) {\n  const res = [[]];\n  const backtrack = (path, index) =&gt; {\n      if(path[path.length -1] === nums[nums.length-1]) {\n          return;\n      }\n      for(let i=index;i&lt;nums.length;i++) { //不重复的元素从startIndex开始，重复的从0开始\n          path.push(nums[i]);\n          res.push([...path]);\n          backtrack(path, i+1);\n          path.pop();\n      }\n  }\n  backtrack([], 0);\n  return res;\n};</code></pre></div>","frontmatter":{"title":"回溯","date":"August 08, 2021","description":"回溯系列题"}},"previous":{"fields":{"slug":"/leetcode/path/"},"frontmatter":{"title":"路径问题"}},"next":null},"pageContext":{"id":"98136373-37e3-5a3c-9b75-e958d0634182","previousPostId":"70e049d3-723d-546b-be1d-1daeac35f30f","nextPostId":null}},"staticQueryHashes":["2841359383","788015585"]}