{"componentChunkName":"component---src-templates-blog-post-js","path":"/leetcode/tree/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"1eee51d5-b225-53de-9f2f-fb1eef872e20","excerpt":"树   树是一种被广泛应用的数据结构，例如： dom是一种树结构数据 os…","html":"<h1>树</h1>\n<p>  树是一种被广泛应用的数据结构，例如：</p>\n<ul>\n<li>dom是一种树结构数据</li>\n<li>os中的文件与目录可以视为树</li>\n<li>家族、族谱</li>\n</ul>\n<p>  堆、二叉排序树等这些不同的树结构可以解决调度、图像处理、数据库的问题。很多复杂问题也许不是第一眼就能看出是树结构，但是使用树结构解决更加简单与高效。</p>\n<h2>导言</h2>\n<p>  树的节点包括值、左节点、右结点，因此节点实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// 可以实现这样的树结构\n//    2\n//   / \\\n//  1   3\n\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nconst root = new Node(2);\nroot.left = new Node(1);\nroot.right = new Node(3)</code></pre></div>\n<h2>遍历</h2>\n<p>分为两种：\n广度优先遍历(层序遍历)\n深度优先遍历</p>\n<h2>广度优先遍历</h2>\n<p>  逐行从左到右遍历\n<img src=\"https://cdn.hashnode.com/res/hashnode/image/upload/v1630066197622/MEa_jdswt.png?auto=compress,format&#x26;format=webp\" alt=\"breadth-first\"></p>\n<p>  广度优先遍历可以采用队列(先进先出)来实现，大致流程如下：</p>\n<ul>\n<li>初始化一个带有根节点的队列</li>\n<li>移出队列的首个结点</li>\n<li>将移出结点的左子节点与右子结点入队</li>\n<li>重复二、三步直到队列为空</li>\n</ul>\n<p>  代码实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function walkbfs(root) {\n  if(!root) return [];\n  const queue = [root], res = [];\n  while(queue.length) {\n    const len = queue.length, level = []; // len 等于当前这一层的节点个数\n    for(let i = 0; i&lt;len; i++) {\n      const item = queue.shift();\n      level.push(item);\n      if(item.left) queue.push(item.left);\n      if(item.right) queue.push(item.right);\n    }\n    res.push(level);\n  }\n}</code></pre></div>\n<p>  变种题：</p>\n<ol start=\"637\">\n<li>二叉树的层平均值\n给定一个非空二叉树, 返回一个由每层节点平均值组成的数组\n示例 1：</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">输入：\n   3\n  / \\\n  9  20\n    /  \\\n  15    7\n输出：[3, 14.5, 11]</code></pre></div>\n<p>  解释：\n第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</p>\n<p>  思路: 将push的值由结点改成平均数</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var averageOfLevels = function(root) {\n  const queue = [root], ans = [];\n  while(queue.length) {\n      const len = queue.length; let total = 0;\n      for(let i=0;i&lt;len;i++) {\n          const item = queue.shift();\n          total+=item.val;\n          if(item.left) queue.push(item.left);\n          if(item.right) queue.push(item.right);\n      }\n      ans.push(total / len);\n  }\n  return ans;\n};</code></pre></div>\n<ol start=\"103\">\n<li>二叉树的锯齿形层序遍历\n给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</li>\n</ol>\n<p>  例如：\n给定二叉树 [3,9,20,null,null,15,7],</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 3\n/ \\\n9  20\n  /  \\\n15   7</code></pre></div>\n<p>  返回锯齿形层序遍历如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[\n  [3],\n  [20,9],\n  [15,7]\n]</code></pre></div>\n<p>   思路：遍历依然是广度遍历，值在需要由右向左时改成unshift</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var zigzagLevelOrder = function(root) {\n  if(!root) return [];\n  const queue = [root], ans = [];\n  let index = 0;\n  while(queue.length) {\n      const len = queue.length, level = [];\n      index++;\n      for(let i=0;i&lt;len;i++) {\n          const item = queue.shift();\n          if(index % 2 === 1) {\n              level.push(item.val)\n          } else {\n              level.unshift(item.val)\n          }\n          if(item.left) queue.push(item.left);  \n          if(item.right) queue.push(item.right);  \n      }\n      ans.push(level);\n  }\n  return ans;\n};</code></pre></div>\n<ol start=\"199\">\n<li>二叉树的右视图\n给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</li>\n</ol>\n<p>  <img src=\"https://assets.leetcode.com/uploads/2021/02/14/tree.jpg\" alt=\"right_view\"></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]</code></pre></div>\n<p>  思路：遍历依然是那个遍历，只存放每一层的最后一个结点值</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var rightSideView = function(root) {\n  if(!root) return [];\n  const queue = [root], res = [];\n  while(queue.length) {\n      const len = queue.length, temp = [];\n      for(let i = 0;i&lt;len;i++) {\n          const item = queue.shift();\n          if(i === len - 1) {\n              res.push(item.val);\n          }\n          if(item.left) queue.push(item.left);\n          if(item.right) queue.push(item.right);\n      }\n  }\n  return res;\n};</code></pre></div>\n<ol start=\"515\">\n<li>在每个树行中找最大值</li>\n</ol>\n<h3>BFS应用二： 最短路径</h3>\n<p>  在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径。其中哪一条路最近为最短路径问题。(先mark)</p>\n<h2>深度优先遍历</h2>\n<p>  深度优先遍历分为：前序遍历、中序遍历、后序遍历</p>\n<h3>前序遍历</h3>\n<p>  根节点 -〉 左节点 -〉 右节点\n实现具体类似层序遍历，不过将队列换成栈(先进后出)\n迭代实现：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var preorderTraversal = function(root) {\n  if(!root) return [];\n  const res = [], stk = [root];\n  while(stk.length) {\n      const item = stk.pop();\n      res.push(item.val);\n      if(item.right) stk.push(item.right);\n      if(item.left) stk.push(item.left);\n  }\n  return res;\n};</code></pre></div>\n<h3>中序遍历</h3>\n<p>  左节点 -> 根节点 -> 右节点\n迭代思路：先找到二叉树的最左节点，然后根节点，最后右节点，所以初步的代码如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const cur = root;\nwhile(cur) {\n  while(cur.left) {\n    cur = cur.left\n  }\n  console.log(cur);\n  cur = cur.right\n}</code></pre></div>\n<p>  但是上述的代码不能回溯，无法回到父节点，所以需要通过栈记录这些节点</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function walkInOrder(root) {\n  const res = [], stk = [];\n  let cur = root;\n  while(cur || stk.length) {\n    while(cur) {\n      stk.push(cur);\n      cur = cur.left;\n    }\n    const item = stk.pop();\n    res.push(item.val);\n    cur = cur.right;\n  }\n  return res;\n}</code></pre></div>\n<h3>后序遍历</h3>\n<p>  左节点 -〉右节点 -〉根节点\n实现思路：前序遍历是根-〉左-〉右， 后序遍历是左-〉右-〉根，利用前序遍历改造下顺序，再反转</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">var postorderTraversal = function(root) {\n  if(!root) return [];\n  const res = [], stk =[root];\n  while(stk.length) {\n      const node = stk.pop();\n      res.push(node.val);\n      if(node.left) stk.push(node.left);\n      if(node.right) stk.push(node.right);\n  }\n  return res.reverse();\n};</code></pre></div>\n<h2>相关阅读</h2>\n<p>  tree-data-structure-in-javascript： <a href=\"https://stackfull.dev/tree-data-structure-in-javascript\">https://stackfull.dev/tree-data-structure-in-javascript</a></p>","frontmatter":{"title":"JS中的树数据结构","date":"October 17, 2021","description":"树的实现和遍历"}},"previous":{"fields":{"slug":"/login/auth/"},"frontmatter":{"title":"阅读笔记之登录鉴权"}},"next":null},"pageContext":{"id":"1eee51d5-b225-53de-9f2f-fb1eef872e20","previousPostId":"45177fb4-7c71-59c4-ac71-0fa70f9c905f","nextPostId":null}},"staticQueryHashes":["2841359383","788015585"]}