{"componentChunkName":"component---src-templates-blog-post-js","path":"/how-browser-work/","result":{"data":{"site":{"siteMetadata":{"title":"chinley's blog"}},"markdownRemark":{"id":"be5763ce-eaa7-5e96-bcba-ac3ef1e67cd0","excerpt":"名词介绍：CPU、GPU、内存和多线程架构 cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。\ngpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu…","html":"<h3>名词介绍：CPU、GPU、内存和多线程架构</h3>\n<p>cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。\ngpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu可以承担更多计算任务。在三层计算机体系结构中，硬件位于底部，操作系统位于中间，应用程序则在最上层。在使用计算机时，应用程序使用操作系统提供的机制在CPU和GPU上运行。\n<img src=\"https://developers.google.com/web/updates/images/inside-browser/part1/hw-os-app.png\" alt=\"hw-os-app\"></p>\n<p>进程：进程可以通过操作系统，启动另一个进程来执行不同的任务。此时，系统将为新进程分配不同的内存；如果两个进程间需要通信，他们可以利用 IPC（Inter Process Communication）的方式进行通信；当启动一个应用程序时，操作系统会分配内存与执行进程，所有应用的状态都会保存在一块私有的内存空间，当应用关闭了，操作系统就会销毁进程，释放内存。</p>\n<p>线程：存在与进程内部，执行进程的部分任务</p>\n<h3>chrome浏览器架构</h3>\n<p>可能是一个具有许多不同线程或许多不同进程的进程，只有少数线程能够通过 IPC 进行通信。\n浏览器有哪些进程：</p>\n<ul>\n<li>1.浏览器进程：控制chrome应用程序，包括地址栏、后退、前进事件等。还有处理网络请求、文件访问等</li>\n<li>2.渲染进程：控制选项卡内、页面内容</li>\n<li>3.GPU进程：处理来自多个进程的请求</li>\n<li>4.插件进程：网站插件的使用\n<img src=\"https://developers.google.com/web/updates/images/inside-browser/part1/browserui.png\" alt=\"hw-os-app\"></li>\n</ul>\n<h3>chrome为什么要使用多线程</h3>\n<ul>\n<li>1.各个进程互不干扰，每个选项卡有自己的进程，不会因为其他进程的错误导致无法响应</li>\n<li>2.安全性与沙盒，对某些进程的权限进行限制，例如，Chrome 浏览器可以对处理用户输入（如渲染器）的进程，限制其文件访问的权限，功能明确清晰。</li>\n</ul>\n<h3>chrome正在致力于服务化与站点隔离</h3>\n<ul>\n<li>1.将浏览器程序的每个部分，作为一项服务运行，从而可以轻松拆分为不同的流程或汇总为同一个流程。</li>\n<li>2.站点隔离，独立渲染。可以为每个跨网站 iframe 运行单独的渲染器进程，确保一个站点在未经允许下，不能向其他站点访问数据。</li>\n</ul>\n<h3>在浏览器中输入url，chrome干了什么？</h3>\n<ul>\n<li>\n<p>1.处理输入</p>\n<p>当用户在地址栏中输入地址，浏览器进程中的UI线程会先判断输入内容是查询搜索还是url?\n在 Chrome 中，地址栏同时具备搜索查询的功能，因此 UI 线程需要解析并确定是将请求发送到搜索引擎，还是发送到待请求的网站。</p>\n</li>\n<li>\n<p>2.开始导航</p>\n<p>UI线程会进行网络请求，以获取页面内容。网络线程会经历dns查找或和建立TL链接等网络协议。这时，网络线程可能收到301服务器重定向，网络线程就会和UI线程通讯，启动对另一个Url的请求。</p>\n</li>\n<li>\n<p>3.读取响应</p>\n<p>开始接收响应体后，网络线程会先读取几个字节。Content-Type响应体会说明数据类型，但由于它可能会丢失或者错误，通过 MIME 类型嗅探，来进一步判断数据类型。</p>\n<p>如果判断是html文件，下一步就是将数据传递给渲染器进程。如果是ZIP文件或其他文件，表示这是下载请求，就会将数据传递给下载管理器。</p>\n<p>网络线程会检查响应数据是否来自安全域名，如果检查到是来自已知的恶意域名，就会发出警告，显示警告页面。</p>\n</li>\n<li>\n<p>4.查找渲染器进程</p>\n<p>当所有检查执行完以及网络线程确定是定位到哪个网址后，UI线程就会让渲染器进程进行页面渲染。</p>\n<p>因为网络线程处理时间较长，所以在步骤2确定了导航的网址后，UI线程就会启动或者查找复用一个渲染进程，与网络进程同步执行。当网络线程开始接收数据时，渲染器进程已处于待用状态。</p>\n</li>\n<li>\n<p>5.提交导航</p>\n<p>提交导航，IPC将从浏览器进程发送一个数据流到渲染器进程。因为此处传递的是一个数据流，渲染器进程可以继续从数据流中接收 HTML 数据。一旦浏览器进程监听到渲染器进程中已经确认提交，一次导航就算完成了，接下来就是文档加载阶段。</p>\n<p>此时，地址栏就会更新，安全锁（HTTPS证书安全）和站点设置 UI 会显示新页面的站点信息。选项卡的历史记录将更新，因此后退/前进按钮将允许操作之前的浏览器历史。同时会将历史记录存储在磁盘上，以确保关闭选项卡或窗口后，依然可以浏览历史以及还原窗口。</p>\n</li>\n<li>\n<p>额外步骤：初始加载完成</p>\n<p>一旦渲染器进程 “完成” 渲染，它就会通过 IPC 将消息通知回浏览器进程（这是在所有页面中的 onload 事件都触发之后执行的）。此时，UI 线程会隐藏选项卡上的加载进度图标。</p>\n<p>这里的 “完成” 之所以加引号，因为客户端 JavaScript 仍然可以加载额外的资源，并在此之后呈现新的视图。</p>\n</li>\n</ul>","frontmatter":{"title":"现代浏览器架构","date":"May 07, 2021","description":"学习笔记: 深入了解现代浏览器架构--以chrome为例"}},"previous":{"fields":{"slug":"/build-a-blog-by-gatsby/"},"frontmatter":{"title":"通过gatsby搭建自己的博客"}},"next":null},"pageContext":{"id":"be5763ce-eaa7-5e96-bcba-ac3ef1e67cd0","previousPostId":"46ffcab6-9535-550e-8e60-660e5d9e1264","nextPostId":null}},"staticQueryHashes":["2841359383","788015585"]}