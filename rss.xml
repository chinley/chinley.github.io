<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[chinley's blog]]></title><description><![CDATA[百事可乐]]></description><link>https://chinleyhuang.ink</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 16 May 2021 10:14:05 GMT</lastBuildDate><item><title><![CDATA[现代浏览器架构]]></title><description><![CDATA[名词介绍：CPU、GPU、内存和多线程架构 cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。
gpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu…]]></description><link>https://chinleyhuang.ink/how-browser-work/</link><guid isPermaLink="false">https://chinleyhuang.ink/how-browser-work/</guid><pubDate>Fri, 07 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;名词介绍：CPU、GPU、内存和多线程架构&lt;/h3&gt;
&lt;p&gt;cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。
gpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu可以承担更多计算任务。在三层计算机体系结构中，硬件位于底部，操作系统位于中间，应用程序则在最上层。在使用计算机时，应用程序使用操作系统提供的机制在CPU和GPU上运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part1/hw-os-app.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程：进程可以通过操作系统，启动另一个进程来执行不同的任务。此时，系统将为新进程分配不同的内存；如果两个进程间需要通信，他们可以利用 IPC（Inter Process Communication）的方式进行通信；当启动一个应用程序时，操作系统会分配内存与执行进程，所有应用的状态都会保存在一块私有的内存空间，当应用关闭了，操作系统就会销毁进程，释放内存。&lt;/p&gt;
&lt;p&gt;线程：存在与进程内部，执行进程的部分任务&lt;/p&gt;
&lt;h3&gt;chrome浏览器架构&lt;/h3&gt;
&lt;p&gt;可能是一个具有许多不同线程或许多不同进程的进程，只有少数线程能够通过 IPC 进行通信。
浏览器有哪些进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.浏览器进程：控制chrome应用程序，包括地址栏、后退、前进事件等。还有处理网络请求、文件访问等&lt;/li&gt;
&lt;li&gt;2.渲染进程：控制选项卡内、页面内容&lt;/li&gt;
&lt;li&gt;3.GPU进程：处理来自多个进程的请求&lt;/li&gt;
&lt;li&gt;4.插件进程：网站插件的使用
&lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part1/browserui.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;chrome为什么要使用多线程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.各个进程互不干扰，每个选项卡有自己的进程，不会因为其他进程的错误导致无法响应&lt;/li&gt;
&lt;li&gt;2.安全性与沙盒，对某些进程的权限进行限制，例如，Chrome 浏览器可以对处理用户输入（如渲染器）的进程，限制其文件访问的权限，功能明确清晰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;chrome正在致力于服务化与站点隔离&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.将浏览器程序的每个部分，作为一项服务运行，从而可以轻松拆分为不同的流程或汇总为同一个流程。&lt;/li&gt;
&lt;li&gt;2.站点隔离，独立渲染。可以为每个跨网站 iframe 运行单独的渲染器进程，确保一个站点在未经允许下，不能向其他站点访问数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在浏览器中输入url，chrome干了什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.处理输入&lt;/p&gt;
&lt;p&gt;当用户在地址栏中输入地址，浏览器进程中的UI线程会先判断输入内容是查询搜索还是url?
在 Chrome 中，地址栏同时具备搜索查询的功能，因此 UI 线程需要解析并确定是将请求发送到搜索引擎，还是发送到待请求的网站。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.开始导航&lt;/p&gt;
&lt;p&gt;UI线程会进行网络请求，以获取页面内容。网络线程会经历dns查找或和建立TL链接等网络协议。这时，网络线程可能收到301服务器重定向，网络线程就会和UI线程通讯，启动对另一个Url的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.读取响应&lt;/p&gt;
&lt;p&gt;开始接收响应体后，网络线程会先读取几个字节。Content-Type响应体会说明数据类型，但由于它可能会丢失或者错误，通过 MIME 类型嗅探，来进一步判断数据类型。&lt;/p&gt;
&lt;p&gt;如果判断是html文件，下一步就是将数据传递给渲染器进程。如果是ZIP文件或其他文件，表示这是下载请求，就会将数据传递给下载管理器。&lt;/p&gt;
&lt;p&gt;网络线程会检查响应数据是否来自安全域名，如果检查到是来自已知的恶意域名，就会发出警告，显示警告页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.查找渲染器进程&lt;/p&gt;
&lt;p&gt;当所有检查执行完以及网络线程确定是定位到哪个网址后，UI线程就会让渲染器进程进行页面渲染。&lt;/p&gt;
&lt;p&gt;因为网络线程处理时间较长，所以在步骤2确定了导航的网址后，UI线程就会启动或者查找复用一个渲染进程，与网络进程同步执行。当网络线程开始接收数据时，渲染器进程已处于待用状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.提交导航&lt;/p&gt;
&lt;p&gt;提交导航，IPC将从浏览器进程发送一个数据流到渲染器进程。因为此处传递的是一个数据流，渲染器进程可以继续从数据流中接收 HTML 数据。一旦浏览器进程监听到渲染器进程中已经确认提交，一次导航就算完成了，接下来就是文档加载阶段。&lt;/p&gt;
&lt;p&gt;此时，地址栏就会更新，安全锁（HTTPS证书安全）和站点设置 UI 会显示新页面的站点信息。选项卡的历史记录将更新，因此后退/前进按钮将允许操作之前的浏览器历史。同时会将历史记录存储在磁盘上，以确保关闭选项卡或窗口后，依然可以浏览历史以及还原窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;额外步骤：初始加载完成&lt;/p&gt;
&lt;p&gt;一旦渲染器进程 “完成” 渲染，它就会通过 IPC 将消息通知回浏览器进程（这是在所有页面中的 onload 事件都触发之后执行的）。此时，UI 线程会隐藏选项卡上的加载进度图标。&lt;/p&gt;
&lt;p&gt;这里的 “完成” 之所以加引号，因为客户端 JavaScript 仍然可以加载额外的资源，并在此之后呈现新的视图。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;渲染器进程—如何将html、css和js处理成可以与用户交互的网页&lt;/h3&gt;
&lt;p&gt;  渲染器进程的核心工作内容是将html、css和js处理成可以与用户交互的网页。&lt;/p&gt;
&lt;h4&gt;解析&lt;/h4&gt;
&lt;p&gt;  渲染器进程开始接收html数据后，主线程就开始处理html，将其处理成DOM&lt;/p&gt;
&lt;h4&gt;子资源加载&lt;/h4&gt;
&lt;p&gt;  为了加快资源加载速度，主线程会启用“预加载扫描”，发现有类似 &lt;img&gt; 或 &lt;link&gt; 这样的标签时，会由 HTML 解析器对该资源生成一个 Tokens，然后在浏览器进程中，通过网络或者本地缓存来加载资源。&lt;/p&gt;
&lt;p&gt;  一个完整的 Web 站点通常会包含图片、CSS 和 JS 等外部资源，这些文件都需要从网络或者本地缓存中加载。主线程可以在解析构建 DOM 的时候，将他们逐个请求。&lt;/p&gt;
&lt;h4&gt;JS可以阻止解析&lt;/h4&gt;
&lt;p&gt;  当 HTML 解析器遇到script 标签的时候，它会暂停解析 HTML 文档，然后对这个 JS 脚本进行加载、解析和执行。因为js脚本可以改变dom元素，因而HTML 解析器在重新解析 HTML 之前，必须等待 JS 脚本执行。&lt;/p&gt;
&lt;p&gt;  HTML 遇到 JS 脚本则暂停对 HTML 的解析，这并不是绝对的。script 标签中添加 async 或 defer 标记，然后浏览器会异步加载和运行此 JS 脚本，不会阻断解析。如果需要，也可以使用 JavaScript Modules，还可以通过 rel=“preload” 标签向浏览器明确标记此为重要的资源，将在页面加载完成之后被立刻使用，对于这类资源，它会在页面加载生命周期的早期，被优先加载。&lt;/p&gt;
&lt;h4&gt;样式渲染&lt;/h4&gt;
&lt;p&gt;  主线程解析css并添加渲染样式。即使不用css，每个dom节点存在默认的样式。&lt;/p&gt;
&lt;h4&gt;布局&lt;/h4&gt;
&lt;p&gt;  主线程遍历dom树并计算样式，然后创建layout树，在布局树中包含元素的x、y坐标和边框大小的信息。举个例子，如果某个元素设置了 display:none，则该元素将不会出现在布局树中，但是它会出现在 DOM 树中，而如果该元素被设置为 visibility:hidden 则它会存在于布局树中。类似的例子还有 p::before{content:“Hi!“}  这样的伪类，它会存在于布局树中，而不会存在于 DOM 树中。&lt;/p&gt;
&lt;h4&gt;绘制&lt;/h4&gt;
&lt;p&gt;  拥有 DOM、CSS 和 LayoutTree 仍然不足以渲染页面。假设你正在尝试重绘一幅画，你除了需要知道元素的大小、外观和位置之外，还需要知道它们的绘制顺序。例如z-index属性的设置，因而在这过程中，主线程遍历布局树，然后创建绘制记录。&lt;/p&gt;
&lt;h4&gt;更新渲染管道&lt;/h4&gt;
&lt;p&gt;  渲染管道（Rendering Pipeline）中最重要的任务，就是在每个步骤开始前，根据前一次操作的结果，来创建新的数据。例如，如果布局树中的某些内容发生更改，则需要为文档的受影响部分重新生成“绘制”顺序。&lt;/p&gt;
&lt;p&gt;  渲染管道（Rendering Pipeline）中最重要的任务，就是在每个步骤开始前，根据前一次操作的结果，来创建新的数据。例如，如果布局树中的某些内容发生变动，则需要为文档中受影响的部分，重新生成“绘制记录”。&lt;/p&gt;
&lt;h3&gt;合成&lt;/h3&gt;
&lt;p&gt;  现在浏览器知道页面的结构、元素样式、绘制顺序，要将这些元素转换为屏幕的像素，称为光栅化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;合成&lt;/h4&gt;
&lt;p&gt;  合成是一种将页面的各个元素进行分层，分别光栅化，并在合成器线程中以一个单独的线程合成新页面的技术。如果页面发生滚动，由于图层已经光栅化，因此它需要做的就是合成一个新帧。通过移动图层同时合成新帧，可以以相同的方式实现动画。&lt;/p&gt;
&lt;h4&gt;分层&lt;/h4&gt;
&lt;p&gt;  为了确定每个元素所在的层，主线程遍历布局树以创建层树（Layer Tree)&lt;/p&gt;
&lt;h4&gt;光栅和合成，脱离主线程&lt;/h4&gt;
&lt;p&gt;  一旦创建了层树并确定了绘制顺序，主线程就会将该信息提交给合成器线程。合成器线程会光栅化每个图层，一个图层可能想一个完整的页面那么大，因此合成器线程将他们分成图块，并将每个图块发送到光栅线程。光栅线程格式化每个元素，并将他们存储在 GPU 内存中。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part3/raster.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  合成器线程可以优先考虑不同的光栅线程，以便 ViewPort（或附近）的元素可以被优先光栅化。图层还具有多个不同分辨率的倾斜度，以便对内容的放大等操作。&lt;/p&gt;
&lt;p&gt;  一旦元素被光栅化，合成器线程会收集被称为 “绘制矩形（Draw Quads）” 的信息，用以创建一个合成帧（Compositor Frame）。&lt;/p&gt;
&lt;p&gt;  然后通过 IPC 将合成帧提交给浏览器进程。此时，可以从 UI 线程添加另一个合成帧用于浏览器的 UI 更新，或者从其他渲染器进程中添加扩展。这些合成帧被发送到 GPU 中，用以在屏幕上显示。如果触发滚动事件，合成器线程会创建另一个合成帧发送到 GPU。&lt;/p&gt;
&lt;p&gt;  合成（Compositor）的好处，是它可以在不影响主线程的情况下完成。合成器线程不需要等待样式计算或者 JS 脚本执行，这就是为什么 “仅合成动画” 被认为是平滑性能的最佳选择。如果需要再次计算不会或者重新绘制，则必须涉及到主线程。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[通过gatsby搭建自己的博客]]></title><description><![CDATA[如何通过gatsby搭建博客 下载gatsby脚手架 npm i gatsby-cli -g 新建一个博客目录  gatsby new blog 运行博客  gatsby develop 在github page上关联gatsby项目 添加项目原地址 git add remote…]]></description><link>https://chinleyhuang.ink/build-a-blog-by-gatsby/</link><guid isPermaLink="false">https://chinleyhuang.ink/build-a-blog-by-gatsby/</guid><pubDate>Tue, 27 Apr 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;如何通过gatsby搭建博客&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载gatsby脚手架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm i gatsby-cli -g&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个博客目录 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gatsby new blog&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行博客 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gatsby develop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在github page上关联gatsby项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加项目原地址 git add remote xxxxx&lt;/li&gt;
&lt;li&gt;如有修改 git add、git push&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包静态资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过gh-pages打包，npm install gh-pages —save-dev&lt;/li&gt;
&lt;li&gt;在packag.json中添加脚本：gatsby build —prefix-paths &amp;#x26;&amp;#x26; gh-pages -d public -b public，gh-pages就会将文件打包到public目录，并提交到分支public&lt;/li&gt;
&lt;li&gt;在github里将项目pages的sources设置为public分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;打包资源成功后，在githubpage的页面就能看到样式啦&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何关联自己的域名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在自己域名下配置dns A类型, 记录值为githubpage ip 185.199.108.153&lt;/li&gt;
&lt;li&gt;添加CNAME dns, 记录值为你的githupage域名&lt;/li&gt;
&lt;li&gt;githupage项目下设置custom domain为自己的域名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;npm i一直停留在sharp-libvips&lt;/h3&gt;
&lt;p&gt;  一些包被墙了，打开vpn也下载不了,需要绑定host&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;192.30.255.112	gist.github.com
192.30.255.112	github.com
192.30.255.112	www.github.com
151.101.56.133	avatars0.githubusercontent.com
151.101.56.133	avatars1.githubusercontent.com
151.101.56.133	avatars2.githubusercontent.com
151.101.56.133	avatars3.githubusercontent.com
151.101.56.133	avatars4.githubusercontent.com
151.101.56.133	avatars5.githubusercontent.com
151.101.56.133	avatars6.githubusercontent.com
151.101.56.133	avatars7.githubusercontent.com
151.101.56.133	avatars8.githubusercontent.com
151.101.56.133	camo.githubusercontent.com
151.101.56.133	cloud.githubusercontent.com
151.101.56.133	gist.githubusercontent.com
151.101.56.133	marketplace-screenshots.githubusercontent.com
151.101.56.133	raw.githubusercontent.com
151.101.56.133	repository-images.githubusercontent.com
151.101.56.133	user-images.githubusercontent.com&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h3&gt;gatsby build WorkerError: failed to process image&lt;/h3&gt;
&lt;p&gt;  删除node_modules再重新npm i，无果，重新下载gatsby-cli，再搭建新的项目&lt;/p&gt;</content:encoded></item></channel></rss>