<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[chinley's blog]]></title><description><![CDATA[百事可乐]]></description><link>https://chinleyhuang.ink</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 15 Aug 2021 09:06:33 GMT</lastBuildDate><item><title><![CDATA[回溯]]></title><description><![CDATA[回溯涉及到的类型：组合：给定几个数字，返回所有组合， 切割：一个字符串做分割， 子集、排列、棋盘   所有的回溯法都可以抽象为一个树形结构 组合题 17. 电话号码的字母组合   给定一个仅包含数字 2-…]]></description><link>https://chinleyhuang.ink/leetcode/recall/</link><guid isPermaLink="false">https://chinleyhuang.ink/leetcode/recall/</guid><pubDate>Sun, 08 Aug 2021 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;  回溯涉及到的类型：组合：给定几个数字，返回所有组合， 切割：一个字符串做分割， 子集、排列、棋盘&lt;/p&gt;
&lt;p&gt;  所有的回溯法都可以抽象为一个树形结构&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function backtrack() {
  if(终止条件) {
    收集结果;
    return;
  }
  for(集合元素) {
    处理节点;
    递归函数;
    回溯
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;组合题&lt;/h3&gt;
&lt;h4&gt;17. 电话号码的字母组合&lt;/h4&gt;
&lt;p&gt;  给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;/p&gt;
&lt;p&gt;  给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  输入：digits = “23”&lt;/p&gt;
&lt;p&gt;  输出：[“ad”,“ae”,“af”,“bd”,“be”,“bf”,“cd”,“ce”,“cf”]&lt;/p&gt;
&lt;p&gt;  解题思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;画树状图，初始化path，作为每个叶子节点结果，res保存结果，index为遍历的深度&lt;/li&gt;
&lt;li&gt;每次遍历path添加字母，遍历完回溯path回退，当index === digits.length时保存结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;code&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var letterCombinations = function(digits) {
    const digitalMap = {
        2: [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;],
        3: [&amp;quot;d&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;f&amp;quot;],
        4: [&amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;],
        5: [&amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;],
        6: [&amp;quot;m&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;o&amp;quot;],
        7: [&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;s&amp;quot;],
        8: [&amp;quot;t&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;v&amp;quot;],
        9: [&amp;quot;w&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;]
    }
    const digitsArray = digits.split(&amp;quot;&amp;quot;);
    const res = [], path = [];
    if(digits.length === 0) return res;
    const backtrack = (path, index) =&amp;gt; {
        if(index === digits.length) {
            res.push(path.join(&amp;#39;&amp;#39;));
            return;
        }
        const curDigits = digitalMap[digitsArray[index]];
        for(let i = 0; i &amp;lt; curDigits.length; i++) {
            path.push(curDigits[i]);
            backtrack(path, index + 1);
            path.pop();
        }
    }
    backtrack(path, 0);
    console.log(res);
    return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;39. 组合总和&lt;/h4&gt;
&lt;p&gt;  给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。&lt;/p&gt;
&lt;p&gt;  candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 &lt;/p&gt;
&lt;p&gt;  对于给定的输入，保证和为 target 的唯一组合数少于 150 个。&lt;/p&gt;
&lt;p&gt;  输入: candidates = [2,3,6,7], target = 7&lt;/p&gt;
&lt;p&gt;  输出: [[7],[2,2,3]]&lt;/p&gt;
&lt;h4&gt;code&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var combinationSum = function(candidates, target) {
  const res = [];
  const backtrack = (path, index) =&amp;gt; {
      const curSum = path.reduce((pre, cur) =&amp;gt; { return pre + cur;}, 0);
      if(curSum &amp;gt; target || index === candidates.length) return;
      if(curSum === target) { 
          res.push([...path]); // res.push(path)，res会跟随path变化，因此需要扩展运算符
          return;
      }
      for(let i = index; i&amp;lt;candidates.length;i++) { //下一次从i的地方开始遍历
          path.push(candidates[i]);
          backtrack(path, i); //下一次从i的地方开始遍历
          path.pop();
      }
  }
  backtrack([], 0);
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;46. 全排列&lt;/h4&gt;
&lt;p&gt;  给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。&lt;/p&gt;
&lt;p&gt;  输入：nums = [1,2,3]&lt;/p&gt;
&lt;p&gt;  输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&lt;/p&gt;
&lt;h5&gt;code&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var permute = function(nums) {
  const res = [];

  const backtrack = (path, index) =&amp;gt; {
      if(path.length === nums.length){
          res.push([...path]);
          return;
      }
      for(let i=0;i&amp;lt;nums.length;i++) {
          if(path.includes(nums[i])) { // 当已存在这个数字，跳过
              continue;
          }
          path.push(nums[i]);
          backtrack(path);
          path.pop();
      }
  }
  backtrack([]);
  console.log(res);
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;22. 括号生成&lt;/h4&gt;
&lt;p&gt;  数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;p&gt;  输入：n = 3&lt;/p&gt;
&lt;p&gt;  输出：[”((()))”,”(()())”,”(())()”,”()(())”,”()()()”]&lt;/p&gt;
&lt;p&gt;  解题思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定终止条件：当(和)数量等于n时，收集结果&lt;/li&gt;
&lt;li&gt;当字符串）比（数量多时，无效括号，需要剪枝&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;code&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var generateParenthesis = function(n) {
  const res = [];
  const backtrack = (lRemaind, rRemaind, str) =&amp;gt; {
      if(lRemaind === 0 &amp;amp;&amp;amp; rRemaind===0) {
          res.push(str);
      }
      if(lRemaind &amp;gt; rRemaind) { // 如果剩余的（比）多，无效分枝，剪枝
          return;
      }

      if(lRemaind&amp;gt;0) {
          backtrack(lRemaind-1,rRemaind, str + &amp;#39;(&amp;#39;);
      }

      if(rRemaind &amp;gt; lRemaind) {
          backtrack(lRemaind,rRemaind - 1, str + &amp;#39;)&amp;#39;);
      }
  }
  backtrack(n,n,&amp;#39;&amp;#39;);
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;78. 子集&lt;/h3&gt;
&lt;p&gt;  给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;  解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。&lt;/p&gt;
&lt;p&gt;  输入：nums = [1,2,3]&lt;/p&gt;
&lt;p&gt;  输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]&lt;/p&gt;
&lt;h4&gt;code&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var subsets = function(nums) {
  const res = [[]];
  const backtrack = (path, index) =&amp;gt; {
      if(path[path.length -1] === nums[nums.length-1]) {
          return;
      }
      for(let i=index;i&amp;lt;nums.length;i++) { //不重复的元素从startIndex开始，重复的从0开始
          path.push(nums[i]);
          res.push([...path]);
          backtrack(path, i+1);
          path.pop();
      }
  }
  backtrack([], 0);
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[路径问题]]></title><description><![CDATA[问题描述   一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。   机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。   问总共有多少条不同的路径？   hw-os-app…]]></description><link>https://chinleyhuang.ink/leetcode/path/</link><guid isPermaLink="false">https://chinleyhuang.ink/leetcode/path/</guid><pubDate>Sun, 01 Aug 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;问题描述&lt;/h3&gt;
&lt;p&gt;  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;  机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。&lt;/p&gt;
&lt;p&gt;  问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  输入：m = 3, n = 7&lt;/p&gt;
&lt;p&gt;  输出：28&lt;/p&gt;
&lt;h3&gt;做题思路&lt;/h3&gt;
&lt;p&gt;  给定终点，不同方向不同路径，或者每步步数不定，典型的动态规划题目&lt;/p&gt;
&lt;p&gt;  动态规划三要素：1.重叠子问题 2.最优子结构 3.状态转移方程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重叠子问题
走到（m,n)位置的路径，由走到（m, n-1)路径数量和走到（m-1，n)路径数量组成&lt;/li&gt;
&lt;li&gt;最优子结构&lt;/li&gt;
&lt;li&gt;状态转移方程&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;f(m,n)=f(m−1,n)+f(m,n−1)

f(i, 0) = 1, i &amp;lt; m

f(0, j) = 1, j &amp;lt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;code&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt; var uniquePaths = function(m, n) {
  const arr = [];
  for(let i = 0; i &amp;lt; m; i++) {
      arr[i] = [];
      arr[i][0] = 1;
  }
  for(let j = 0; j&amp;lt;n; j++) {
      arr[0][j] = 1;
  }
  for(let i=1;i&amp;lt;m;i++) {
      for(let j=1;j&amp;lt;n;j++) {
          arr[i][j] = arr[i-1][j] + arr[i][j-1];
      }
  }

  return arr[m-1][n-1];
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;延伸题&lt;/h3&gt;
&lt;h4&gt;不同路径 II&lt;/h4&gt;
&lt;p&gt;  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;  机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;  现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  解题思路： 当有0时把当前点置0，边界中若f(i,0)有障碍，则 i&amp;#x3C; j &amp;#x3C; m都要置0&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var uniquePathsWithObstacles = function(obstacleGrid) {
  const n = obstacleGrid.length, m = obstacleGrid[0].length;
  const arr = createArray(m,n);
  arr[0][0] = obstacleGrid[0][0] ? 0 : 1;
  for(let i= 1;i&amp;lt;m;i++) {
      arr[0][i] = obstacleGrid[0][i] === 1 ? 0 : arr[0][i-1];
  }

  for(let j=1;j&amp;lt;n;j++) {
      arr[j][0] = obstacleGrid[j][0] === 1 ? 0 : arr[j-1][0];
  }
  for(let i = 1; i&amp;lt; m; i++) {
      for(let j=1;j&amp;lt;n;j++) {
          arr[j][i] = obstacleGrid[j][i] === 1 ? 0 : arr[j-1][i] + arr[j][i-1];
      }
  }
  return arr[n-1][m-1];
};

function createArray(m,n) {
  return new Array(n).fill(&amp;#39;&amp;#39;).map(() =&amp;gt; new Array(m).fill(0));
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;路径最小和&lt;/h4&gt;
&lt;p&gt;  给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;  说明：每次只能向下或者向右移动一步。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  输入：grid = [[1,3,1],[1,5,1],[4,2,1]]&lt;/p&gt;
&lt;p&gt;  输出：7&lt;/p&gt;
&lt;p&gt;  解释：因为路径 1→3→1→1→1 的总和最小。&lt;/p&gt;
&lt;p&gt;  把（m,n)上的数字表示成a(m,n),路径(m,n)上数字最小和为Sum(m,n)&lt;/p&gt;
&lt;p&gt;  Sum(m,n) = Math.min(Sum(m-1,n), Sum(m, n-1)) + a(m,n)&lt;/p&gt;
&lt;p&gt;  表中的数据把路径之和替换为路径的最小数&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;  var minPathSum = function(grid) {
    const n = grid.length, m = grid[0].length;
    const arr = createArray(m,n);
    arr[0][0] = grid[0][0];
    for(let i = 1; i &amp;lt; m; i++) {
        arr[0][i] = arr[0][i-1] + grid[0][i];
    }

    for(let j = 1; j &amp;lt; n; j++) {
        arr[j][0] = arr[j-1][0] + grid[j][0];
    }

    for(let i = 1; i&amp;lt;m; i++) {
        for(let j =1; j&amp;lt;n;j++) {
            arr[j][i] = grid[j][i] + Math.min(arr[j][i-1], arr[j-1][i]);
        }
    }
    
    return arr[n-1][m-1];
};

function createArray(m,n) {
    return new Array(n).fill(&amp;#39;&amp;#39;).map(()=&amp;gt;new Array(m).fill(0));
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[前端基础建设与架构]]></title><description><![CDATA[npm安装机制与企业级部署私服原理 npm内部机制和核心原理   优先安装依赖到当前的项目目录，使得不同项目依赖自成体系。   npm安装流程：   1.执行npm install后，首先检查npm配置。npm配置文件优先级：项目级.npmrc > 用户级.npmrc…]]></description><link>https://chinleyhuang.ink/npm/</link><guid isPermaLink="false">https://chinleyhuang.ink/npm/</guid><pubDate>Thu, 10 Jun 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h1&gt;npm安装机制与企业级部署私服原理&lt;/h1&gt;
&lt;h2&gt;npm内部机制和核心原理&lt;/h2&gt;
&lt;p&gt;  优先安装依赖到当前的项目目录，使得不同项目依赖自成体系。&lt;/p&gt;
&lt;p&gt;  npm安装流程：&lt;/p&gt;
&lt;p&gt;  1.执行npm install后，首先检查npm配置。npm配置文件优先级：项目级.npmrc &gt; 用户级.npmrc &gt; 全局级.npmrc &gt; npm内置的.npmrc&lt;/p&gt;
&lt;p&gt;  2.检查完配置后，检查package-lock.json文件是否和package.json文件声明的依赖一致：&lt;/p&gt;
&lt;p&gt;   a.一致，直接使用package-lock.json文件，从缓存或者网络中加载依赖&lt;/p&gt;
&lt;p&gt;   b.不一致，按照npm版本处理，不同版本处理方式不同。&lt;/p&gt;
&lt;p&gt;  3.如果没有package-lock.json文件，则根据packge,json构建递归依赖树，按照依赖树下载资源，在下载过程中就会检查是否有相关资源缓存。&lt;/p&gt;
&lt;p&gt;   a.存在缓存资源，将缓存资源解压到node_modules中&lt;/p&gt;
&lt;p&gt;   b.不存在，从npm下载包，检验包的完整，添加到缓存中，并解压到node_modules.&lt;/p&gt;
&lt;p&gt;  最后生成packge-lock.json文件&lt;/p&gt;
&lt;h2&gt;npm link 本地调试包在项目中的可用性&lt;/h2&gt;</content:encoded></item><item><title><![CDATA[最长回文字符串]]></title><description><![CDATA[最长回文字符串   从下标i为1开始遍历字符串str，以stri为中心扩展查找最长字符串]]></description><link>https://chinleyhuang.ink/leetcode/</link><guid isPermaLink="false">https://chinleyhuang.ink/leetcode/</guid><pubDate>Sun, 23 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;最长回文字符串&lt;/h3&gt;
&lt;p&gt;  从下标i为1开始遍历字符串str，以str[i]为中心扩展查找最长字符串&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var find = function(start, end, s) {
  while(start &amp;gt;= 0 &amp;amp;&amp;amp; end &amp;lt; s.length &amp;amp;&amp;amp; s[start] === s[end] &amp;amp;&amp;amp; start &amp;lt;= end) {
      start-=1;
      end+=1;
  }
  return [start+1, end-1]; // 因为退出while循环时s[start] ！== s[end]，因此需要回退上一个值
}

var max = function(start1, end1, start2, end2) {
  return (end1 - start1) &amp;gt; (end2 - start2) ? [start1, end1] : [start2, end2];
}

var longestPalindrome = function(s) {
  if(s.length == 1) {
      return s;
  }
  let len = s.length - 1;
  let start = 0, end = 0;
  for(let i= 1;i&amp;lt;=len;i++) {
      const [start1, end1] = find(i,i,s);
      const [start2, end2] = find(i-1, i, s);
      const [maxStart, maxEnd] = max(start1, end1, start2, end2);
      if((maxEnd - maxStart) &amp;gt;= (end - start)) {
          start = maxStart;
          end = maxEnd;
      }
  }
  return s.substring(start, end+1); // substring不包含end下标的值，因此需要+1
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[webpack学习]]></title><description><![CDATA[webpack 模块打包工具 为什么需要webpack   1.解决浏览器兼容问题
  2.将散落的模块打包 到一起，解决频繁请求的问题
  3.支持将不同的资源，例如图片、字体等作为模块调用，便于维护与处理业务 模块打包   1.定义打包入口 entry, entry…]]></description><link>https://chinleyhuang.ink/webpack/</link><guid isPermaLink="false">https://chinleyhuang.ink/webpack/</guid><pubDate>Tue, 18 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h1&gt;webpack 模块打包工具&lt;/h1&gt;
&lt;h2&gt;为什么需要webpack&lt;/h2&gt;
&lt;p&gt;  1.解决浏览器兼容问题
2.将散落的模块打包 到一起，解决频繁请求的问题
3.支持将不同的资源，例如图片、字体等作为模块调用，便于维护与处理业务&lt;/p&gt;
&lt;h2&gt;模块打包&lt;/h2&gt;
&lt;p&gt;  1.定义打包入口 entry, entry内部默认是只能处理javascript代码
2.配置打包出口 output
3.三种配置模式：
1.development: 自动优化加载速度，添加辅助工作的插件
2.production: 自动优化打包结果，打包速度偏慢
3.node: 不作任何操作&lt;/p&gt;
&lt;h2&gt;loader机制：实现特殊资源加载&lt;/h2&gt;
&lt;p&gt;  css-loader只把css模块加载到js中，并不会使用这个模块
style-loade把css-loader转换后的结果通过追加style的方式加载到页面上
一旦配置多个 Loader，执行顺序是从后往前执行的&lt;/p&gt;
&lt;h2&gt;插件机制：增强webpack自动化构建的能力&lt;/h2&gt;
&lt;h3&gt;常用插件&lt;/h3&gt;
&lt;p&gt;  clean-webpack-plugin: 实现自动在打包之前清除 dist 目录（上次的打包结果）&lt;/p&gt;</content:encoded></item><item><title><![CDATA[现代浏览器架构]]></title><description><![CDATA[名词介绍：CPU、GPU、内存和多线程架构 cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。
gpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu…]]></description><link>https://chinleyhuang.ink/how-browser-work/</link><guid isPermaLink="false">https://chinleyhuang.ink/how-browser-work/</guid><pubDate>Fri, 07 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;名词介绍：CPU、GPU、内存和多线程架构&lt;/h3&gt;
&lt;p&gt;cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。
gpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu可以承担更多计算任务。在三层计算机体系结构中，硬件位于底部，操作系统位于中间，应用程序则在最上层。在使用计算机时，应用程序使用操作系统提供的机制在CPU和GPU上运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part1/hw-os-app.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程：进程可以通过操作系统，启动另一个进程来执行不同的任务。此时，系统将为新进程分配不同的内存；如果两个进程间需要通信，他们可以利用 IPC（Inter Process Communication）的方式进行通信；当启动一个应用程序时，操作系统会分配内存与执行进程，所有应用的状态都会保存在一块私有的内存空间，当应用关闭了，操作系统就会销毁进程，释放内存。&lt;/p&gt;
&lt;p&gt;线程：存在与进程内部，执行进程的部分任务&lt;/p&gt;
&lt;h3&gt;chrome浏览器架构&lt;/h3&gt;
&lt;p&gt;可能是一个具有许多不同线程或许多不同进程的进程，只有少数线程能够通过 IPC 进行通信。
浏览器有哪些进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.浏览器进程：控制chrome应用程序，包括地址栏、后退、前进事件等。还有处理网络请求、文件访问等&lt;/li&gt;
&lt;li&gt;2.渲染进程：控制选项卡内、页面内容&lt;/li&gt;
&lt;li&gt;3.GPU进程：处理来自多个进程的请求&lt;/li&gt;
&lt;li&gt;4.插件进程：网站插件的使用
&lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part1/browserui.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;chrome为什么要使用多线程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.各个进程互不干扰，每个选项卡有自己的进程，不会因为其他进程的错误导致无法响应&lt;/li&gt;
&lt;li&gt;2.安全性与沙盒，对某些进程的权限进行限制，例如，Chrome 浏览器可以对处理用户输入（如渲染器）的进程，限制其文件访问的权限，功能明确清晰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;chrome正在致力于服务化与站点隔离&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.将浏览器程序的每个部分，作为一项服务运行，从而可以轻松拆分为不同的流程或汇总为同一个流程。&lt;/li&gt;
&lt;li&gt;2.站点隔离，独立渲染。可以为每个跨网站 iframe 运行单独的渲染器进程，确保一个站点在未经允许下，不能向其他站点访问数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在浏览器中输入url，chrome干了什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.处理输入&lt;/p&gt;
&lt;p&gt;当用户在地址栏中输入地址，浏览器进程中的UI线程会先判断输入内容是查询搜索还是url?
在 Chrome 中，地址栏同时具备搜索查询的功能，因此 UI 线程需要解析并确定是将请求发送到搜索引擎，还是发送到待请求的网站。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.开始导航&lt;/p&gt;
&lt;p&gt;UI线程会进行网络请求，以获取页面内容。网络线程会经历dns查找或和建立TL链接等网络协议。这时，网络线程可能收到301服务器重定向，网络线程就会和UI线程通讯，启动对另一个Url的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.读取响应&lt;/p&gt;
&lt;p&gt;开始接收响应体后，网络线程会先读取几个字节。Content-Type响应体会说明数据类型，但由于它可能会丢失或者错误，通过 MIME 类型嗅探，来进一步判断数据类型。&lt;/p&gt;
&lt;p&gt;如果判断是html文件，下一步就是将数据传递给渲染器进程。如果是ZIP文件或其他文件，表示这是下载请求，就会将数据传递给下载管理器。&lt;/p&gt;
&lt;p&gt;网络线程会检查响应数据是否来自安全域名，如果检查到是来自已知的恶意域名，就会发出警告，显示警告页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.查找渲染器进程&lt;/p&gt;
&lt;p&gt;当所有检查执行完以及网络线程确定是定位到哪个网址后，UI线程就会让渲染器进程进行页面渲染。&lt;/p&gt;
&lt;p&gt;因为网络线程处理时间较长，所以在步骤2确定了导航的网址后，UI线程就会启动或者查找复用一个渲染进程，与网络进程同步执行。当网络线程开始接收数据时，渲染器进程已处于待用状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.提交导航&lt;/p&gt;
&lt;p&gt;提交导航，IPC将从浏览器进程发送一个数据流到渲染器进程。因为此处传递的是一个数据流，渲染器进程可以继续从数据流中接收 HTML 数据。一旦浏览器进程监听到渲染器进程中已经确认提交，一次导航就算完成了，接下来就是文档加载阶段。&lt;/p&gt;
&lt;p&gt;此时，地址栏就会更新，安全锁（HTTPS证书安全）和站点设置 UI 会显示新页面的站点信息。选项卡的历史记录将更新，因此后退/前进按钮将允许操作之前的浏览器历史。同时会将历史记录存储在磁盘上，以确保关闭选项卡或窗口后，依然可以浏览历史以及还原窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;额外步骤：初始加载完成&lt;/p&gt;
&lt;p&gt;一旦渲染器进程 “完成” 渲染，它就会通过 IPC 将消息通知回浏览器进程（这是在所有页面中的 onload 事件都触发之后执行的）。此时，UI 线程会隐藏选项卡上的加载进度图标。&lt;/p&gt;
&lt;p&gt;这里的 “完成” 之所以加引号，因为客户端 JavaScript 仍然可以加载额外的资源，并在此之后呈现新的视图。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;渲染器进程—如何将html、css和js处理成可以与用户交互的网页&lt;/h3&gt;
&lt;p&gt;  渲染器进程的核心工作内容是将html、css和js处理成可以与用户交互的网页。&lt;/p&gt;
&lt;h4&gt;解析&lt;/h4&gt;
&lt;p&gt;  渲染器进程开始接收html数据后，主线程就开始处理html，将其处理成DOM&lt;/p&gt;
&lt;h4&gt;子资源加载&lt;/h4&gt;
&lt;p&gt;  为了加快资源加载速度，主线程会启用“预加载扫描”，发现有类似 img 或 link 这样的标签时，会由 HTML 解析器对该资源生成一个 Tokens，然后在浏览器进程中，通过网络或者本地缓存来加载资源。&lt;/p&gt;
&lt;p&gt;  一个完整的 Web 站点通常会包含图片、CSS 和 JS 等外部资源，这些文件都需要从网络或者本地缓存中加载。主线程可以在解析构建 DOM 的时候，将他们逐个请求。&lt;/p&gt;
&lt;h4&gt;JS可以阻止解析&lt;/h4&gt;
&lt;p&gt;  当 HTML 解析器遇到script 标签的时候，它会暂停解析 HTML 文档，然后对这个 JS 脚本进行加载、解析和执行。因为js脚本可以改变dom元素，因而HTML 解析器在重新解析 HTML 之前，必须等待 JS 脚本执行。&lt;/p&gt;
&lt;p&gt;  HTML 遇到 JS 脚本则暂停对 HTML 的解析，这并不是绝对的。script 标签中添加 async 或 defer 标记，然后浏览器会异步加载和运行此 JS 脚本，不会阻断解析。如果需要，也可以使用 JavaScript Modules，还可以通过 rel=“preload” 标签向浏览器明确标记此为重要的资源，将在页面加载完成之后被立刻使用，对于这类资源，它会在页面加载生命周期的早期，被优先加载。&lt;/p&gt;
&lt;h4&gt;样式渲染&lt;/h4&gt;
&lt;p&gt;  主线程解析css并添加渲染样式。即使不用css，每个dom节点存在默认的样式。&lt;/p&gt;
&lt;h4&gt;布局&lt;/h4&gt;
&lt;p&gt;  主线程遍历dom树并计算样式，然后创建layout树，在布局树中包含元素的x、y坐标和边框大小的信息。举个例子，如果某个元素设置了 display:none，则该元素将不会出现在布局树中，但是它会出现在 DOM 树中，而如果该元素被设置为 visibility:hidden 则它会存在于布局树中。类似的例子还有 p::before{content:“Hi!“}  这样的伪类，它会存在于布局树中，而不会存在于 DOM 树中。&lt;/p&gt;
&lt;h4&gt;绘制&lt;/h4&gt;
&lt;p&gt;  拥有 DOM、CSS 和 LayoutTree 仍然不足以渲染页面。假设你正在尝试重绘一幅画，你除了需要知道元素的大小、外观和位置之外，还需要知道它们的绘制顺序。例如z-index属性的设置，因而在这过程中，主线程遍历布局树，然后创建绘制记录。&lt;/p&gt;
&lt;h4&gt;更新渲染管道&lt;/h4&gt;
&lt;p&gt;  渲染管道（Rendering Pipeline）中最重要的任务，就是在每个步骤开始前，根据前一次操作的结果，来创建新的数据。例如，如果布局树中的某些内容发生更改，则需要为文档的受影响部分重新生成“绘制”顺序。&lt;/p&gt;
&lt;p&gt;  渲染管道（Rendering Pipeline）中最重要的任务，就是在每个步骤开始前，根据前一次操作的结果，来创建新的数据。例如，如果布局树中的某些内容发生变动，则需要为文档中受影响的部分，重新生成“绘制记录”。&lt;/p&gt;
&lt;h3&gt;合成&lt;/h3&gt;
&lt;p&gt;  现在浏览器知道页面的结构、元素样式、绘制顺序，要将这些元素转换为屏幕的像素，称为光栅化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;合成&lt;/h4&gt;
&lt;p&gt;  合成是一种将页面的各个元素进行分层，分别光栅化，并在合成器线程中以一个单独的线程合成新页面的技术。如果页面发生滚动，由于图层已经光栅化，因此它需要做的就是合成一个新帧。通过移动图层同时合成新帧，可以以相同的方式实现动画。&lt;/p&gt;
&lt;h4&gt;分层&lt;/h4&gt;
&lt;p&gt;  为了确定每个元素所在的层，主线程遍历布局树以创建层树（Layer Tree)&lt;/p&gt;
&lt;h4&gt;光栅和合成，脱离主线程&lt;/h4&gt;
&lt;p&gt;  一旦创建了层树并确定了绘制顺序，主线程就会将该信息提交给合成器线程。合成器线程会光栅化每个图层，一个图层可能想一个完整的页面那么大，因此合成器线程将他们分成图块，并将每个图块发送到光栅线程。光栅线程格式化每个元素，并将他们存储在 GPU 内存中。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part3/raster.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  合成器线程可以优先考虑不同的光栅线程，以便 ViewPort（或附近）的元素可以被优先光栅化。图层还具有多个不同分辨率的倾斜度，以便对内容的放大等操作。&lt;/p&gt;
&lt;p&gt;  一旦元素被光栅化，合成器线程会收集被称为 “绘制矩形（Draw Quads）” 的信息，用以创建一个合成帧（Compositor Frame）。&lt;/p&gt;
&lt;p&gt;  然后通过 IPC 将合成帧提交给浏览器进程。此时，可以从 UI 线程添加另一个合成帧用于浏览器的 UI 更新，或者从其他渲染器进程中添加扩展。这些合成帧被发送到 GPU 中，用以在屏幕上显示。如果触发滚动事件，合成器线程会创建另一个合成帧发送到 GPU。&lt;/p&gt;
&lt;p&gt;  合成（Compositor）的好处，是它可以在不影响主线程的情况下完成。合成器线程不需要等待样式计算或者 JS 脚本执行，这就是为什么 “仅合成动画” 被认为是平滑性能的最佳选择。如果需要再次计算不会或者重新绘制，则必须涉及到主线程。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[通过gatsby搭建自己的博客]]></title><description><![CDATA[如何通过gatsby搭建博客 下载gatsby脚手架 npm i gatsby-cli -g 新建一个博客目录  gatsby new blog 运行博客  gatsby develop 在github page上关联gatsby项目 添加项目原地址 git add remote…]]></description><link>https://chinleyhuang.ink/build-a-blog-by-gatsby/</link><guid isPermaLink="false">https://chinleyhuang.ink/build-a-blog-by-gatsby/</guid><pubDate>Tue, 27 Apr 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;如何通过gatsby搭建博客&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载gatsby脚手架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm i gatsby-cli -g&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个博客目录 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gatsby new blog&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行博客 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gatsby develop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在github page上关联gatsby项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加项目原地址 git add remote xxxxx&lt;/li&gt;
&lt;li&gt;如有修改 git add、git push&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包静态资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过gh-pages打包，npm install gh-pages —save-dev&lt;/li&gt;
&lt;li&gt;在packag.json中添加脚本：gatsby build —prefix-paths &amp;#x26;&amp;#x26; gh-pages -d public -b public，gh-pages就会将文件打包到public目录，并提交到分支public&lt;/li&gt;
&lt;li&gt;在github里将项目pages的sources设置为public分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;打包资源成功后，在githubpage的页面就能看到样式啦&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何关联自己的域名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在自己域名下配置dns A类型, 记录值为githubpage ip 185.199.108.153&lt;/li&gt;
&lt;li&gt;添加CNAME dns, 记录值为你的githupage域名&lt;/li&gt;
&lt;li&gt;githupage项目下设置custom domain为自己的域名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;npm i一直停留在sharp-libvips&lt;/h3&gt;
&lt;p&gt;  一些包被墙了，打开vpn也下载不了,需要绑定host&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;192.30.255.112	gist.github.com
192.30.255.112	github.com
192.30.255.112	www.github.com
151.101.56.133	avatars0.githubusercontent.com
151.101.56.133	avatars1.githubusercontent.com
151.101.56.133	avatars2.githubusercontent.com
151.101.56.133	avatars3.githubusercontent.com
151.101.56.133	avatars4.githubusercontent.com
151.101.56.133	avatars5.githubusercontent.com
151.101.56.133	avatars6.githubusercontent.com
151.101.56.133	avatars7.githubusercontent.com
151.101.56.133	avatars8.githubusercontent.com
151.101.56.133	camo.githubusercontent.com
151.101.56.133	cloud.githubusercontent.com
151.101.56.133	gist.githubusercontent.com
151.101.56.133	marketplace-screenshots.githubusercontent.com
151.101.56.133	raw.githubusercontent.com
151.101.56.133	repository-images.githubusercontent.com
151.101.56.133	user-images.githubusercontent.com&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h3&gt;gatsby build WorkerError: failed to process image&lt;/h3&gt;
&lt;p&gt;  删除node_modules再重新npm i，无果，重新下载gatsby-cli，再搭建新的项目&lt;/p&gt;</content:encoded></item></channel></rss>