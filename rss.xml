<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[chinley's blog]]></title><description><![CDATA[百事可乐]]></description><link>https://chinleyhuang.ink</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 11 May 2021 15:05:22 GMT</lastBuildDate><item><title><![CDATA[现代浏览器架构]]></title><description><![CDATA[名词介绍：CPU、GPU、内存和多线程架构 cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。
gpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu…]]></description><link>https://chinleyhuang.ink/how-browser-work/</link><guid isPermaLink="false">https://chinleyhuang.ink/how-browser-work/</guid><pubDate>Fri, 07 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;名词介绍：CPU、GPU、内存和多线程架构&lt;/h3&gt;
&lt;p&gt;cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。
gpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu可以承担更多计算任务。在三层计算机体系结构中，硬件位于底部，操作系统位于中间，应用程序则在最上层。在使用计算机时，应用程序使用操作系统提供的机制在CPU和GPU上运行。
&lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part1/hw-os-app.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程：进程可以通过操作系统，启动另一个进程来执行不同的任务。此时，系统将为新进程分配不同的内存；如果两个进程间需要通信，他们可以利用 IPC（Inter Process Communication）的方式进行通信；当启动一个应用程序时，操作系统会分配内存与执行进程，所有应用的状态都会保存在一块私有的内存空间，当应用关闭了，操作系统就会销毁进程，释放内存。&lt;/p&gt;
&lt;p&gt;线程：存在与进程内部，执行进程的部分任务&lt;/p&gt;
&lt;h3&gt;chrome浏览器架构&lt;/h3&gt;
&lt;p&gt;可能是一个具有许多不同线程或许多不同进程的进程，只有少数线程能够通过 IPC 进行通信。
浏览器有哪些进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.浏览器进程：控制chrome应用程序，包括地址栏、后退、前进事件等。还有处理网络请求、文件访问等&lt;/li&gt;
&lt;li&gt;2.渲染进程：控制选项卡内、页面内容&lt;/li&gt;
&lt;li&gt;3.GPU进程：处理来自多个进程的请求&lt;/li&gt;
&lt;li&gt;4.插件进程：网站插件的使用
&lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part1/browserui.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;chrome为什么要使用多线程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.各个进程互不干扰，每个选项卡有自己的进程，不会因为其他进程的错误导致无法响应&lt;/li&gt;
&lt;li&gt;2.安全性与沙盒，对某些进程的权限进行限制，例如，Chrome 浏览器可以对处理用户输入（如渲染器）的进程，限制其文件访问的权限，功能明确清晰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;chrome正在致力于服务化与站点隔离&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.将浏览器程序的每个部分，作为一项服务运行，从而可以轻松拆分为不同的流程或汇总为同一个流程。&lt;/li&gt;
&lt;li&gt;2.站点隔离，独立渲染。可以为每个跨网站 iframe 运行单独的渲染器进程，确保一个站点在未经允许下，不能向其他站点访问数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在浏览器中输入url，chrome干了什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.处理输入&lt;/p&gt;
&lt;p&gt;当用户在地址栏中输入地址，浏览器进程中的UI线程会先判断输入内容是查询搜索还是url?
在 Chrome 中，地址栏同时具备搜索查询的功能，因此 UI 线程需要解析并确定是将请求发送到搜索引擎，还是发送到待请求的网站。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.开始导航&lt;/p&gt;
&lt;p&gt;UI线程会进行网络请求，以获取页面内容。网络线程会经历dns查找或和建立TL链接等网络协议。这时，网络线程可能收到301服务器重定向，网络线程就会和UI线程通讯，启动对另一个Url的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.读取响应&lt;/p&gt;
&lt;p&gt;开始接收响应体后，网络线程会先读取几个字节。Content-Type响应体会说明数据类型，但由于它可能会丢失或者错误，通过 MIME 类型嗅探，来进一步判断数据类型。&lt;/p&gt;
&lt;p&gt;如果判断是html文件，下一步就是将数据传递给渲染器进程。如果是ZIP文件或其他文件，表示这是下载请求，就会将数据传递给下载管理器。&lt;/p&gt;
&lt;p&gt;网络线程会检查响应数据是否来自安全域名，如果检查到是来自已知的恶意域名，就会发出警告，显示警告页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.查找渲染器进程&lt;/p&gt;
&lt;p&gt;当所有检查执行完以及网络线程确定是定位到哪个网址后，UI线程就会让渲染器进程进行页面渲染。&lt;/p&gt;
&lt;p&gt;因为网络线程处理时间较长，所以在步骤2确定了导航的网址后，UI线程就会启动或者查找复用一个渲染进程，与网络进程同步执行。当网络线程开始接收数据时，渲染器进程已处于待用状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.提交导航&lt;/p&gt;
&lt;p&gt;提交导航，IPC将从浏览器进程发送一个数据流到渲染器进程。因为此处传递的是一个数据流，渲染器进程可以继续从数据流中接收 HTML 数据。一旦浏览器进程监听到渲染器进程中已经确认提交，一次导航就算完成了，接下来就是文档加载阶段。&lt;/p&gt;
&lt;p&gt;此时，地址栏就会更新，安全锁（HTTPS证书安全）和站点设置 UI 会显示新页面的站点信息。选项卡的历史记录将更新，因此后退/前进按钮将允许操作之前的浏览器历史。同时会将历史记录存储在磁盘上，以确保关闭选项卡或窗口后，依然可以浏览历史以及还原窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;额外步骤：初始加载完成&lt;/p&gt;
&lt;p&gt;一旦渲染器进程 “完成” 渲染，它就会通过 IPC 将消息通知回浏览器进程（这是在所有页面中的 onload 事件都触发之后执行的）。此时，UI 线程会隐藏选项卡上的加载进度图标。&lt;/p&gt;
&lt;p&gt;这里的 “完成” 之所以加引号，因为客户端 JavaScript 仍然可以加载额外的资源，并在此之后呈现新的视图。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[通过gatsby搭建自己的博客]]></title><description><![CDATA[如何通过gatsby搭建博客 下载gatsby脚手架 npm i gatsby-cli -g 新建一个博客目录  gatsby new blog 运行博客  gatsby develop 在github page上关联gatsby项目 添加项目原地址 git add remote…]]></description><link>https://chinleyhuang.ink/build-a-blog-by-gatsby/</link><guid isPermaLink="false">https://chinleyhuang.ink/build-a-blog-by-gatsby/</guid><pubDate>Tue, 27 Apr 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;如何通过gatsby搭建博客&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载gatsby脚手架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm i gatsby-cli -g&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个博客目录 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gatsby new blog&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行博客 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gatsby develop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在github page上关联gatsby项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加项目原地址 git add remote xxxxx&lt;/li&gt;
&lt;li&gt;如有修改 git add、git push&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包静态资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过gh-pages打包，npm install gh-pages —save-dev&lt;/li&gt;
&lt;li&gt;在packag.json中添加脚本：gatsby build —prefix-paths &amp;#x26;&amp;#x26; gh-pages -d public -b public，gh-pages就会将文件打包到public目录，并提交到分支public&lt;/li&gt;
&lt;li&gt;在github里将项目pages的sources设置为public分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;打包资源成功后，在githubpage的页面就能看到样式啦&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何关联自己的域名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在自己域名下配置dns A类型, 记录值为githubpage ip 185.199.108.153&lt;/li&gt;
&lt;li&gt;添加CNAME dns, 记录值为你的githupage域名&lt;/li&gt;
&lt;li&gt;githupage项目下设置custom domain为自己的域名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;npm i一直停留在sharp-libvips&lt;/h3&gt;
&lt;p&gt;  一些包被墙了，打开vpn也下载不了,需要绑定host&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;192.30.255.112	gist.github.com
192.30.255.112	github.com
192.30.255.112	www.github.com
151.101.56.133	avatars0.githubusercontent.com
151.101.56.133	avatars1.githubusercontent.com
151.101.56.133	avatars2.githubusercontent.com
151.101.56.133	avatars3.githubusercontent.com
151.101.56.133	avatars4.githubusercontent.com
151.101.56.133	avatars5.githubusercontent.com
151.101.56.133	avatars6.githubusercontent.com
151.101.56.133	avatars7.githubusercontent.com
151.101.56.133	avatars8.githubusercontent.com
151.101.56.133	camo.githubusercontent.com
151.101.56.133	cloud.githubusercontent.com
151.101.56.133	gist.githubusercontent.com
151.101.56.133	marketplace-screenshots.githubusercontent.com
151.101.56.133	raw.githubusercontent.com
151.101.56.133	repository-images.githubusercontent.com
151.101.56.133	user-images.githubusercontent.com&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h3&gt;gatsby build WorkerError: failed to process image&lt;/h3&gt;
&lt;p&gt;  删除node_modules再重新npm i，无果，重新下载gatsby-cli，再搭建新的项目&lt;/p&gt;</content:encoded></item></channel></rss>