<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[chinley's blog]]></title><description><![CDATA[百事可乐]]></description><link>https://chinleyhuang.ink</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 31 Oct 2021 10:07:41 GMT</lastBuildDate><item><title><![CDATA[JS中的树数据结构]]></title><description><![CDATA[树   树是一种被广泛应用的数据结构，例如： dom是一种树结构数据 os…]]></description><link>https://chinleyhuang.ink/leetcode/tree/</link><guid isPermaLink="false">https://chinleyhuang.ink/leetcode/tree/</guid><pubDate>Sun, 17 Oct 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h1&gt;树&lt;/h1&gt;
&lt;p&gt;  树是一种被广泛应用的数据结构，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dom是一种树结构数据&lt;/li&gt;
&lt;li&gt;os中的文件与目录可以视为树&lt;/li&gt;
&lt;li&gt;家族、族谱&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  堆、二叉排序树等这些不同的树结构可以解决调度、图像处理、数据库的问题。很多复杂问题也许不是第一眼就能看出是树结构，但是使用树结构解决更加简单与高效。&lt;/p&gt;
&lt;h2&gt;导言&lt;/h2&gt;
&lt;p&gt;  树的节点包括值、左节点、右结点，因此节点实现：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// 可以实现这样的树结构
//    2
//   / \
//  1   3

function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}
const root = new Node(2);
root.left = new Node(1);
root.right = new Node(3)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;遍历&lt;/h2&gt;
&lt;p&gt;分为两种：
广度优先遍历(层序遍历)
深度优先遍历&lt;/p&gt;
&lt;h2&gt;广度优先遍历&lt;/h2&gt;
&lt;p&gt;  逐行从左到右遍历
&lt;img src=&quot;https://cdn.hashnode.com/res/hashnode/image/upload/v1630066197622/MEa_jdswt.png?auto=compress,format&amp;#x26;format=webp&quot; alt=&quot;breadth-first&quot;&gt;&lt;/p&gt;
&lt;p&gt;  广度优先遍历可以采用队列(先进先出)来实现，大致流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化一个带有根节点的队列&lt;/li&gt;
&lt;li&gt;移出队列的首个结点&lt;/li&gt;
&lt;li&gt;将移出结点的左子节点与右子结点入队&lt;/li&gt;
&lt;li&gt;重复二、三步直到队列为空&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  代码实现：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function walkbfs(root) {
  if(!root) return [];
  const queue = [root], res = [];
  while(queue.length) {
    const len = queue.length, level = []; // len 等于当前这一层的节点个数
    for(let i = 0; i&amp;lt;len; i++) {
      const item = queue.shift();
      level.push(item);
      if(item.left) queue.push(item.left);
      if(item.right) queue.push(item.right);
    }
    res.push(level);
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  变种题：&lt;/p&gt;
&lt;ol start=&quot;637&quot;&gt;
&lt;li&gt;二叉树的层平均值
给定一个非空二叉树, 返回一个由每层节点平均值组成的数组
示例 1：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入：
   3
  / \
  9  20
    /  \
  15    7
输出：[3, 14.5, 11]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  解释：
第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。&lt;/p&gt;
&lt;p&gt;  思路: 将push的值由结点改成平均数&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var averageOfLevels = function(root) {
  const queue = [root], ans = [];
  while(queue.length) {
      const len = queue.length; let total = 0;
      for(let i=0;i&amp;lt;len;i++) {
          const item = queue.shift();
          total+=item.val;
          if(item.left) queue.push(item.left);
          if(item.right) queue.push(item.right);
      }
      ans.push(total / len);
  }
  return ans;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;103&quot;&gt;
&lt;li&gt;二叉树的锯齿形层序遍历
给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  例如：
给定二叉树 [3,9,20,null,null,15,7],&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt; 3
/ \
9  20
  /  \
15   7&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  返回锯齿形层序遍历如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;[
  [3],
  [20,9],
  [15,7]
]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   思路：遍历依然是广度遍历，值在需要由右向左时改成unshift&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var zigzagLevelOrder = function(root) {
  if(!root) return [];
  const queue = [root], ans = [];
  let index = 0;
  while(queue.length) {
      const len = queue.length, level = [];
      index++;
      for(let i=0;i&amp;lt;len;i++) {
          const item = queue.shift();
          if(index % 2 === 1) {
              level.push(item.val)
          } else {
              level.unshift(item.val)
          }
          if(item.left) queue.push(item.left);  
          if(item.right) queue.push(item.right);  
      }
      ans.push(level);
  }
  return ans;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;199&quot;&gt;
&lt;li&gt;二叉树的右视图
给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode.com/uploads/2021/02/14/tree.jpg&quot; alt=&quot;right_view&quot;&gt;&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;输入: [1,2,3,null,5,null,4]
输出: [1,3,4]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  思路：遍历依然是那个遍历，只存放每一层的最后一个结点值&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var rightSideView = function(root) {
  if(!root) return [];
  const queue = [root], res = [];
  while(queue.length) {
      const len = queue.length, temp = [];
      for(let i = 0;i&amp;lt;len;i++) {
          const item = queue.shift();
          if(i === len - 1) {
              res.push(item.val);
          }
          if(item.left) queue.push(item.left);
          if(item.right) queue.push(item.right);
      }
  }
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol start=&quot;515&quot;&gt;
&lt;li&gt;在每个树行中找最大值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;BFS应用二： 最短路径&lt;/h3&gt;
&lt;p&gt;  在一棵树中，一个结点到另一个结点的路径是唯一的，但在图中，结点之间可能有多条路径。其中哪一条路最近为最短路径问题。(先mark)&lt;/p&gt;
&lt;h2&gt;深度优先遍历&lt;/h2&gt;
&lt;p&gt;  深度优先遍历分为：前序遍历、中序遍历、后序遍历&lt;/p&gt;
&lt;h3&gt;前序遍历&lt;/h3&gt;
&lt;p&gt;  根节点 -〉 左节点 -〉 右节点
实现具体类似层序遍历，不过将队列换成栈(先进后出)
迭代实现：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var preorderTraversal = function(root) {
  if(!root) return [];
  const res = [], stk = [root];
  while(stk.length) {
      const item = stk.pop();
      res.push(item.val);
      if(item.right) stk.push(item.right);
      if(item.left) stk.push(item.left);
  }
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;中序遍历&lt;/h3&gt;
&lt;p&gt;  左节点 -&gt; 根节点 -&gt; 右节点
迭代思路：先找到二叉树的最左节点，然后根节点，最后右节点，所以初步的代码如下：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const cur = root;
while(cur) {
  while(cur.left) {
    cur = cur.left
  }
  console.log(cur);
  cur = cur.right
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  但是上述的代码不能回溯，无法回到父节点，所以需要通过栈记录这些节点&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function walkInOrder(root) {
  const res = [], stk = [];
  let cur = root;
  while(cur || stk.length) {
    while(cur) {
      stk.push(cur);
      cur = cur.left;
    }
    const item = stk.pop();
    res.push(item.val);
    cur = cur.right;
  }
  return res;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;后序遍历&lt;/h3&gt;
&lt;p&gt;  左节点 -〉右节点 -〉根节点
实现思路：前序遍历是根-〉左-〉右， 后序遍历是左-〉右-〉根，利用前序遍历改造下顺序，再反转&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var postorderTraversal = function(root) {
  if(!root) return [];
  const res = [], stk =[root];
  while(stk.length) {
      const node = stk.pop();
      res.push(node.val);
      if(node.left) stk.push(node.left);
      if(node.right) stk.push(node.right);
  }
  return res.reverse();
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;相关阅读&lt;/h2&gt;
&lt;p&gt;  tree-data-structure-in-javascript： &lt;a href=&quot;https://stackfull.dev/tree-data-structure-in-javascript&quot;&gt;https://stackfull.dev/tree-data-structure-in-javascript&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[阅读笔记之登录鉴权]]></title><link>https://chinleyhuang.ink/login/auth/</link><guid isPermaLink="false">https://chinleyhuang.ink/login/auth/</guid><pubDate>Tue, 14 Sep 2021 23:46:37 GMT</pubDate><content:encoded></content:encoded></item><item><title><![CDATA[视频直播技术原理]]></title><description><![CDATA[问题 视频直播技术原理、具体在繁星中的表现 视频直播加速 怎样录制直播视频 怎样实时上传直播视频 怎样播放直播视频 直播间的用户是如何交互]]></description><link>https://chinleyhuang.ink/fanxing/video/</link><guid isPermaLink="false">https://chinleyhuang.ink/fanxing/video/</guid><pubDate>Wed, 08 Sep 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;视频直播技术原理、具体在繁星中的表现&lt;/li&gt;
&lt;li&gt;视频直播加速&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;怎样录制直播视频&lt;/p&gt;
&lt;p&gt;怎样实时上传直播视频&lt;/p&gt;
&lt;p&gt;怎样播放直播视频&lt;/p&gt;
&lt;p&gt;直播间的用户是如何交互&lt;/p&gt;</content:encoded></item><item><title><![CDATA[滑动算法]]></title><description><![CDATA[滑动：按照一定的方向来
窗口：大小不是固定的，可以不断扩张，也可以不断缩小]]></description><link>https://chinleyhuang.ink/leetcode/sliding/</link><guid isPermaLink="false">https://chinleyhuang.ink/leetcode/sliding/</guid><pubDate>Mon, 16 Aug 2021 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;滑动：按照一定的方向来
窗口：大小不是固定的，可以不断扩张，也可以不断缩小&lt;/p&gt;</content:encoded></item><item><title><![CDATA[回溯]]></title><description><![CDATA[回溯涉及到的类型：组合：给定几个数字，返回所有组合， 切割：一个字符串做分割， 子集、排列、棋盘   所有的回溯法都可以抽象为一个树形结构 组合题 17. 电话号码的字母组合   给定一个仅包含数字 2-…]]></description><link>https://chinleyhuang.ink/leetcode/recall/</link><guid isPermaLink="false">https://chinleyhuang.ink/leetcode/recall/</guid><pubDate>Sun, 08 Aug 2021 23:46:37 GMT</pubDate><content:encoded>&lt;p&gt;  回溯涉及到的类型：组合：给定几个数字，返回所有组合， 切割：一个字符串做分割， 子集、排列、棋盘&lt;/p&gt;
&lt;p&gt;  所有的回溯法都可以抽象为一个树形结构&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;function backtrack() {
  if(终止条件) {
    收集结果;
    return;
  }
  for(集合元素) {
    处理节点;
    递归函数;
    回溯
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;组合题&lt;/h3&gt;
&lt;h4&gt;17. 电话号码的字母组合&lt;/h4&gt;
&lt;p&gt;  给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。&lt;/p&gt;
&lt;p&gt;  给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  输入：digits = “23”&lt;/p&gt;
&lt;p&gt;  输出：[“ad”,“ae”,“af”,“bd”,“be”,“bf”,“cd”,“ce”,“cf”]&lt;/p&gt;
&lt;p&gt;  解题思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;画树状图，初始化path，作为每个叶子节点结果，res保存结果，index为遍历的深度&lt;/li&gt;
&lt;li&gt;每次遍历path添加字母，遍历完回溯path回退，当index === digits.length时保存结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;code&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var letterCombinations = function(digits) {
    const digitalMap = {
        2: [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;],
        3: [&amp;quot;d&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;f&amp;quot;],
        4: [&amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;],
        5: [&amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;],
        6: [&amp;quot;m&amp;quot;, &amp;quot;n&amp;quot;, &amp;quot;o&amp;quot;],
        7: [&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;, &amp;quot;s&amp;quot;],
        8: [&amp;quot;t&amp;quot;, &amp;quot;u&amp;quot;, &amp;quot;v&amp;quot;],
        9: [&amp;quot;w&amp;quot;, &amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;]
    }
    const digitsArray = digits.split(&amp;quot;&amp;quot;);
    const res = [], path = [];
    if(digits.length === 0) return res;
    const backtrack = (path, index) =&amp;gt; {
        if(index === digits.length) {
            res.push(path.join(&amp;#39;&amp;#39;));
            return;
        }
        const curDigits = digitalMap[digitsArray[index]];
        for(let i = 0; i &amp;lt; curDigits.length; i++) {
            path.push(curDigits[i]);
            backtrack(path, index + 1);
            path.pop();
        }
    }
    backtrack(path, 0);
    console.log(res);
    return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;39. 组合总和&lt;/h4&gt;
&lt;p&gt;  给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。&lt;/p&gt;
&lt;p&gt;  candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 &lt;/p&gt;
&lt;p&gt;  对于给定的输入，保证和为 target 的唯一组合数少于 150 个。&lt;/p&gt;
&lt;p&gt;  输入: candidates = [2,3,6,7], target = 7&lt;/p&gt;
&lt;p&gt;  输出: [[7],[2,2,3]]&lt;/p&gt;
&lt;h4&gt;code&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var combinationSum = function(candidates, target) {
  const res = [];
  const backtrack = (path, index) =&amp;gt; {
      const curSum = path.reduce((pre, cur) =&amp;gt; { return pre + cur;}, 0);
      if(curSum &amp;gt; target || index === candidates.length) return;
      if(curSum === target) { 
          res.push([...path]); // res.push(path)，res会跟随path变化，因此需要扩展运算符
          return;
      }
      for(let i = index; i&amp;lt;candidates.length;i++) { //下一次从i的地方开始遍历
          path.push(candidates[i]);
          backtrack(path, i); //下一次从i的地方开始遍历
          path.pop();
      }
  }
  backtrack([], 0);
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;46. 全排列&lt;/h4&gt;
&lt;p&gt;  给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。&lt;/p&gt;
&lt;p&gt;  输入：nums = [1,2,3]&lt;/p&gt;
&lt;p&gt;  输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&lt;/p&gt;
&lt;h5&gt;code&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var permute = function(nums) {
  const res = [];

  const backtrack = (path, index) =&amp;gt; {
      if(path.length === nums.length){
          res.push([...path]);
          return;
      }
      for(let i=0;i&amp;lt;nums.length;i++) {
          if(path.includes(nums[i])) { // 当已存在这个数字，跳过
              continue;
          }
          path.push(nums[i]);
          backtrack(path);
          path.pop();
      }
  }
  backtrack([]);
  console.log(res);
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;22. 括号生成&lt;/h4&gt;
&lt;p&gt;  数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。&lt;/p&gt;
&lt;p&gt;  输入：n = 3&lt;/p&gt;
&lt;p&gt;  输出：[”((()))”,”(()())”,”(())()”,”()(())”,”()()()”]&lt;/p&gt;
&lt;p&gt;  解题思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确定终止条件：当(和)数量等于n时，收集结果&lt;/li&gt;
&lt;li&gt;当字符串）比（数量多时，无效括号，需要剪枝&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;code&lt;/h5&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var generateParenthesis = function(n) {
  const res = [];
  const backtrack = (lRemaind, rRemaind, str) =&amp;gt; {
      if(lRemaind === 0 &amp;amp;&amp;amp; rRemaind===0) {
          res.push(str);
      }
      if(lRemaind &amp;gt; rRemaind) { // 如果剩余的（比）多，无效分枝，剪枝
          return;
      }

      if(lRemaind&amp;gt;0) {
          backtrack(lRemaind-1,rRemaind, str + &amp;#39;(&amp;#39;);
      }

      if(rRemaind &amp;gt; lRemaind) {
          backtrack(lRemaind,rRemaind - 1, str + &amp;#39;)&amp;#39;);
      }
  }
  backtrack(n,n,&amp;#39;&amp;#39;);
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;78. 子集&lt;/h3&gt;
&lt;p&gt;  给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。&lt;/p&gt;
&lt;p&gt;  解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。&lt;/p&gt;
&lt;p&gt;  输入：nums = [1,2,3]&lt;/p&gt;
&lt;p&gt;  输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]&lt;/p&gt;
&lt;h4&gt;code&lt;/h4&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var subsets = function(nums) {
  const res = [[]];
  const backtrack = (path, index) =&amp;gt; {
      if(path[path.length -1] === nums[nums.length-1]) {
          return;
      }
      for(let i=index;i&amp;lt;nums.length;i++) { //不重复的元素从startIndex开始，重复的从0开始
          path.push(nums[i]);
          res.push([...path]);
          backtrack(path, i+1);
          path.pop();
      }
  }
  backtrack([], 0);
  return res;
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[路径问题]]></title><description><![CDATA[问题描述   一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。   机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。   问总共有多少条不同的路径？   hw-os-app…]]></description><link>https://chinleyhuang.ink/leetcode/path/</link><guid isPermaLink="false">https://chinleyhuang.ink/leetcode/path/</guid><pubDate>Sun, 01 Aug 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;问题描述&lt;/h3&gt;
&lt;p&gt;  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。&lt;/p&gt;
&lt;p&gt;  机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。&lt;/p&gt;
&lt;p&gt;  问总共有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  输入：m = 3, n = 7&lt;/p&gt;
&lt;p&gt;  输出：28&lt;/p&gt;
&lt;h3&gt;做题思路&lt;/h3&gt;
&lt;p&gt;  给定终点，不同方向不同路径，或者每步步数不定，典型的动态规划题目&lt;/p&gt;
&lt;p&gt;  动态规划三要素：1.重叠子问题 2.最优子结构 3.状态转移方程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重叠子问题
走到（m,n)位置的路径，由走到（m, n-1)路径数量和走到（m-1，n)路径数量组成&lt;/li&gt;
&lt;li&gt;最优子结构&lt;/li&gt;
&lt;li&gt;状态转移方程&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;f(m,n)=f(m−1,n)+f(m,n−1)

f(i, 0) = 1, i &amp;lt; m

f(0, j) = 1, j &amp;lt; n&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;code&lt;/h3&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt; var uniquePaths = function(m, n) {
  const arr = [];
  for(let i = 0; i &amp;lt; m; i++) {
      arr[i] = [];
      arr[i][0] = 1;
  }
  for(let j = 0; j&amp;lt;n; j++) {
      arr[0][j] = 1;
  }
  for(let i=1;i&amp;lt;m;i++) {
      for(let j=1;j&amp;lt;n;j++) {
          arr[i][j] = arr[i-1][j] + arr[i][j-1];
      }
  }

  return arr[m-1][n-1];
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;延伸题&lt;/h3&gt;
&lt;h4&gt;不同路径 II&lt;/h4&gt;
&lt;p&gt;  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;  机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;  现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  解题思路： 当有0时把当前点置0，边界中若f(i,0)有障碍，则 i&amp;#x3C; j &amp;#x3C; m都要置0&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var uniquePathsWithObstacles = function(obstacleGrid) {
  const n = obstacleGrid.length, m = obstacleGrid[0].length;
  const arr = createArray(m,n);
  arr[0][0] = obstacleGrid[0][0] ? 0 : 1;
  for(let i= 1;i&amp;lt;m;i++) {
      arr[0][i] = obstacleGrid[0][i] === 1 ? 0 : arr[0][i-1];
  }

  for(let j=1;j&amp;lt;n;j++) {
      arr[j][0] = obstacleGrid[j][0] === 1 ? 0 : arr[j-1][0];
  }
  for(let i = 1; i&amp;lt; m; i++) {
      for(let j=1;j&amp;lt;n;j++) {
          arr[j][i] = obstacleGrid[j][i] === 1 ? 0 : arr[j-1][i] + arr[j][i-1];
      }
  }
  return arr[n-1][m-1];
};

function createArray(m,n) {
  return new Array(n).fill(&amp;#39;&amp;#39;).map(() =&amp;gt; new Array(m).fill(0));
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;路径最小和&lt;/h4&gt;
&lt;p&gt;  给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;  说明：每次只能向下或者向右移动一步。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  输入：grid = [[1,3,1],[1,5,1],[4,2,1]]&lt;/p&gt;
&lt;p&gt;  输出：7&lt;/p&gt;
&lt;p&gt;  解释：因为路径 1→3→1→1→1 的总和最小。&lt;/p&gt;
&lt;p&gt;  把（m,n)上的数字表示成a(m,n),路径(m,n)上数字最小和为Sum(m,n)&lt;/p&gt;
&lt;p&gt;  Sum(m,n) = Math.min(Sum(m-1,n), Sum(m, n-1)) + a(m,n)&lt;/p&gt;
&lt;p&gt;  表中的数据把路径之和替换为路径的最小数&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;  var minPathSum = function(grid) {
    const n = grid.length, m = grid[0].length;
    const arr = createArray(m,n);
    arr[0][0] = grid[0][0];
    for(let i = 1; i &amp;lt; m; i++) {
        arr[0][i] = arr[0][i-1] + grid[0][i];
    }

    for(let j = 1; j &amp;lt; n; j++) {
        arr[j][0] = arr[j-1][0] + grid[j][0];
    }

    for(let i = 1; i&amp;lt;m; i++) {
        for(let j =1; j&amp;lt;n;j++) {
            arr[j][i] = grid[j][i] + Math.min(arr[j][i-1], arr[j-1][i]);
        }
    }
    
    return arr[n-1][m-1];
};

function createArray(m,n) {
    return new Array(n).fill(&amp;#39;&amp;#39;).map(()=&amp;gt;new Array(m).fill(0));
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[前端基础建设与架构]]></title><description><![CDATA[npm内部机制和核心原理   优先安装依赖到当前的项目目录，使得不同项目依赖自成体系。   npm安装流程：   1.执行npm install后，首先检查npm配置。npm配置文件优先级：项目级.npmrc > 用户级.npmrc > 全局级.npmrc > npm…]]></description><link>https://chinleyhuang.ink/npm/</link><guid isPermaLink="false">https://chinleyhuang.ink/npm/</guid><pubDate>Thu, 10 Jun 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h2&gt;npm内部机制和核心原理&lt;/h2&gt;
&lt;p&gt;  优先安装依赖到当前的项目目录，使得不同项目依赖自成体系。&lt;/p&gt;
&lt;p&gt;  npm安装流程：&lt;/p&gt;
&lt;p&gt;  1.执行npm install后，首先检查npm配置。npm配置文件优先级：项目级.npmrc &gt; 用户级.npmrc &gt; 全局级.npmrc &gt; npm内置的.npmrc&lt;/p&gt;
&lt;p&gt;  2.检查完配置后，检查package-lock.json文件是否和package.json文件声明的依赖一致：&lt;/p&gt;
&lt;p&gt;   a.一致，直接使用package-lock.json文件，从缓存或者网络中加载依赖&lt;/p&gt;
&lt;p&gt;   b.不一致，按照npm版本处理，不同版本处理方式不同。&lt;/p&gt;
&lt;p&gt;  3.如果没有package-lock.json文件，则根据packge,json构建递归依赖树，按照依赖树下载资源，在下载过程中就会检查是否有相关资源缓存。&lt;/p&gt;
&lt;p&gt;   a.存在缓存资源，将缓存资源解压到node_modules中&lt;/p&gt;
&lt;p&gt;   b.不存在，从npm下载包，检验包的完整，添加到缓存中，并解压到node_modules.&lt;/p&gt;
&lt;p&gt;  最后生成packge-lock.json文件&lt;/p&gt;
&lt;p&gt;  本地开发node_modules下的npm包，npm link&lt;/p&gt;
&lt;p&gt;  npx vs npm，npx 可以快速执行node_modules包下的命令&lt;/p&gt;
&lt;p&gt;  npx eslint —init vs ./node_modules/.bin/eslint —init&lt;/p&gt;
&lt;h2&gt;yarn vs npm&lt;/h2&gt;
&lt;p&gt;  yarn是更新的包管理工具，用于弥补一些npm的不足, 出现时机在npm v3时&lt;/p&gt;
&lt;p&gt;  npm缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;npm i慢&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一个项目，安装的版本无法保证一致性&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;quot;5.0.3&amp;quot;, // 指定5.0.3版本
&amp;quot;~5.0.3&amp;quot;, // 安装5.0.x中的最新版本
&amp;quot;^5.0.3&amp;quot; // 安装5.x.x中的最新版本&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;包会在同一时间下载和安装，中途某个时候，一个包抛出了一个错误，但是npm会继续下载和安装包。因为npm会把所有的日志输出到终端，有关错误包的错误信息就会在一大堆npm打印的警告中丢失掉，并且你甚至永远不会注意到实际发生的错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  yarn优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不同于npm串行安装，yarn并行安装&lt;/li&gt;
&lt;li&gt;安装版本统一&lt;/li&gt;
&lt;li&gt;更简洁的输出&lt;/li&gt;
&lt;li&gt;更语义化 npm install react —save vs	yarn add react&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;  npm dedupe 简化依赖树&lt;/p&gt;
&lt;h2&gt;为什么要lockfiles&lt;/h2&gt;
&lt;p&gt;  lockfiles出现的原因：完整准确地还原项目依赖&lt;/p&gt;</content:encoded></item><item><title><![CDATA[最长回文字符串]]></title><description><![CDATA[最长回文字符串   从下标i为1开始遍历字符串str，以stri为中心扩展查找最长字符串]]></description><link>https://chinleyhuang.ink/leetcode/</link><guid isPermaLink="false">https://chinleyhuang.ink/leetcode/</guid><pubDate>Sun, 23 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;最长回文字符串&lt;/h3&gt;
&lt;p&gt;  从下标i为1开始遍历字符串str，以str[i]为中心扩展查找最长字符串&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;var find = function(start, end, s) {
  while(start &amp;gt;= 0 &amp;amp;&amp;amp; end &amp;lt; s.length &amp;amp;&amp;amp; s[start] === s[end] &amp;amp;&amp;amp; start &amp;lt;= end) {
      start-=1;
      end+=1;
  }
  return [start+1, end-1]; // 因为退出while循环时s[start] ！== s[end]，因此需要回退上一个值
}

var max = function(start1, end1, start2, end2) {
  return (end1 - start1) &amp;gt; (end2 - start2) ? [start1, end1] : [start2, end2];
}

var longestPalindrome = function(s) {
  if(s.length == 1) {
      return s;
  }
  let len = s.length - 1;
  let start = 0, end = 0;
  for(let i= 1;i&amp;lt;=len;i++) {
      const [start1, end1] = find(i,i,s);
      const [start2, end2] = find(i-1, i, s);
      const [maxStart, maxEnd] = max(start1, end1, start2, end2);
      if((maxEnd - maxStart) &amp;gt;= (end - start)) {
          start = maxStart;
          end = maxEnd;
      }
  }
  return s.substring(start, end+1); // substring不包含end下标的值，因此需要+1
};&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item><item><title><![CDATA[webpack学习]]></title><description><![CDATA[webpack 模块打包工具 为什么需要webpack   1.解决浏览器兼容问题
  2.将散落的模块打包到一起，解决频繁请求的问题
  3.支持将不同的资源，例如图片、字体等作为模块调用，便于维护与处理业务 模块打包   1.定义打包入口 entry, entry…]]></description><link>https://chinleyhuang.ink/webpack/</link><guid isPermaLink="false">https://chinleyhuang.ink/webpack/</guid><pubDate>Tue, 18 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h1&gt;webpack 模块打包工具&lt;/h1&gt;
&lt;h2&gt;为什么需要webpack&lt;/h2&gt;
&lt;p&gt;  1.解决浏览器兼容问题
2.将散落的模块打包到一起，解决频繁请求的问题
3.支持将不同的资源，例如图片、字体等作为模块调用，便于维护与处理业务&lt;/p&gt;
&lt;h2&gt;模块打包&lt;/h2&gt;
&lt;p&gt;  1.定义打包入口 entry, entry内部默认是只能处理javascript代码
2.配置打包出口 output
3.三种配置模式：
1.development: 自动优化加载速度，添加辅助工作的插件
2.production: 自动优化打包结果，打包速度偏慢
3.node: 不作任何操作&lt;/p&gt;
&lt;h2&gt;loader机制：实现特殊资源加载&lt;/h2&gt;
&lt;p&gt;  css-loader只把css模块加载到js中，并不会使用这个模块
style-loade把css-loader转换后的结果通过追加style的方式加载到页面上
一旦配置多个 Loader，执行顺序是从后往前执行的&lt;/p&gt;
&lt;h2&gt;插件机制：增强webpack自动化构建的能力&lt;/h2&gt;
&lt;h3&gt;常用插件&lt;/h3&gt;
&lt;p&gt;  clean-webpack-plugin: 实现自动在打包之前清除 dist 目录（上次的打包结果）&lt;/p&gt;</content:encoded></item><item><title><![CDATA[babel]]></title><description><![CDATA[Babel是什么   Babel就是一个JS的“编译器”。主要因为前端语言特性和宿主(浏览器/node.js)环境高速发展，但宿主环境对新语言的特性支持无法做到时，而开发者又需要兼容各种宿主环境，因此需要语言特性的降级。   babel…]]></description><link>https://chinleyhuang.ink/webpack/babel/</link><guid isPermaLink="false">https://chinleyhuang.ink/webpack/babel/</guid><pubDate>Tue, 18 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;Babel是什么&lt;/h3&gt;
&lt;p&gt;  Babel就是一个JS的“编译器”。主要因为前端语言特性和宿主(浏览器/node.js)环境高速发展，但宿主环境对新语言的特性支持无法做到时，而开发者又需要兼容各种宿主环境，因此需要语言特性的降级。&lt;/p&gt;
&lt;p&gt;  babel主要完成以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法转换，一般是高级语言特性的降级&lt;/li&gt;
&lt;li&gt;polyfill特性的实现和接入&lt;/li&gt;
&lt;li&gt;源码转换，比如JSX等&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[现代浏览器架构]]></title><description><![CDATA[名词介绍：CPU、GPU、内存和多线程架构 cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。
gpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu…]]></description><link>https://chinleyhuang.ink/how-browser-work/</link><guid isPermaLink="false">https://chinleyhuang.ink/how-browser-work/</guid><pubDate>Fri, 07 May 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;名词介绍：CPU、GPU、内存和多线程架构&lt;/h3&gt;
&lt;p&gt;cpu: 中央处理器，分为单核处理器和多核处理器，在现代硬件中，大多是多核处理器。
gpu: 图形处理器，最初被设计为是处理图形的，但随着近年的发展，gpu可以承担更多计算任务。在三层计算机体系结构中，硬件位于底部，操作系统位于中间，应用程序则在最上层。在使用计算机时，应用程序使用操作系统提供的机制在CPU和GPU上运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part1/hw-os-app.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;进程：进程可以通过操作系统，启动另一个进程来执行不同的任务。此时，系统将为新进程分配不同的内存；如果两个进程间需要通信，他们可以利用 IPC（Inter Process Communication）的方式进行通信；当启动一个应用程序时，操作系统会分配内存与执行进程，所有应用的状态都会保存在一块私有的内存空间，当应用关闭了，操作系统就会销毁进程，释放内存。&lt;/p&gt;
&lt;p&gt;线程：存在与进程内部，执行进程的部分任务&lt;/p&gt;
&lt;h3&gt;chrome浏览器架构&lt;/h3&gt;
&lt;p&gt;可能是一个具有许多不同线程或许多不同进程的进程，只有少数线程能够通过 IPC 进行通信。
浏览器有哪些进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.浏览器进程：控制chrome应用程序，包括地址栏、后退、前进事件等。还有处理网络请求、文件访问等&lt;/li&gt;
&lt;li&gt;2.渲染进程：控制选项卡内、页面内容&lt;/li&gt;
&lt;li&gt;3.GPU进程：处理来自多个进程的请求&lt;/li&gt;
&lt;li&gt;4.插件进程：网站插件的使用
&lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part1/browserui.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;chrome为什么要使用多线程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.各个进程互不干扰，每个选项卡有自己的进程，不会因为其他进程的错误导致无法响应&lt;/li&gt;
&lt;li&gt;2.安全性与沙盒，对某些进程的权限进行限制，例如，Chrome 浏览器可以对处理用户输入（如渲染器）的进程，限制其文件访问的权限，功能明确清晰。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;chrome正在致力于服务化与站点隔离&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.将浏览器程序的每个部分，作为一项服务运行，从而可以轻松拆分为不同的流程或汇总为同一个流程。&lt;/li&gt;
&lt;li&gt;2.站点隔离，独立渲染。可以为每个跨网站 iframe 运行单独的渲染器进程，确保一个站点在未经允许下，不能向其他站点访问数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;在浏览器中输入url，chrome干了什么？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.处理输入&lt;/p&gt;
&lt;p&gt;当用户在地址栏中输入地址，浏览器进程中的UI线程会先判断输入内容是查询搜索还是url?
在 Chrome 中，地址栏同时具备搜索查询的功能，因此 UI 线程需要解析并确定是将请求发送到搜索引擎，还是发送到待请求的网站。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.开始导航&lt;/p&gt;
&lt;p&gt;UI线程会进行网络请求，以获取页面内容。网络线程会经历dns查找或和建立TL链接等网络协议。这时，网络线程可能收到301服务器重定向，网络线程就会和UI线程通讯，启动对另一个Url的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3.读取响应&lt;/p&gt;
&lt;p&gt;开始接收响应体后，网络线程会先读取几个字节。Content-Type响应体会说明数据类型，但由于它可能会丢失或者错误，通过 MIME 类型嗅探，来进一步判断数据类型。&lt;/p&gt;
&lt;p&gt;如果判断是html文件，下一步就是将数据传递给渲染器进程。如果是ZIP文件或其他文件，表示这是下载请求，就会将数据传递给下载管理器。&lt;/p&gt;
&lt;p&gt;网络线程会检查响应数据是否来自安全域名，如果检查到是来自已知的恶意域名，就会发出警告，显示警告页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4.查找渲染器进程&lt;/p&gt;
&lt;p&gt;当所有检查执行完以及网络线程确定是定位到哪个网址后，UI线程就会让渲染器进程进行页面渲染。&lt;/p&gt;
&lt;p&gt;因为网络线程处理时间较长，所以在步骤2确定了导航的网址后，UI线程就会启动或者查找复用一个渲染进程，与网络进程同步执行。当网络线程开始接收数据时，渲染器进程已处于待用状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;5.提交导航&lt;/p&gt;
&lt;p&gt;提交导航，IPC将从浏览器进程发送一个数据流到渲染器进程。因为此处传递的是一个数据流，渲染器进程可以继续从数据流中接收 HTML 数据。一旦浏览器进程监听到渲染器进程中已经确认提交，一次导航就算完成了，接下来就是文档加载阶段。&lt;/p&gt;
&lt;p&gt;此时，地址栏就会更新，安全锁（HTTPS证书安全）和站点设置 UI 会显示新页面的站点信息。选项卡的历史记录将更新，因此后退/前进按钮将允许操作之前的浏览器历史。同时会将历史记录存储在磁盘上，以确保关闭选项卡或窗口后，依然可以浏览历史以及还原窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;额外步骤：初始加载完成&lt;/p&gt;
&lt;p&gt;一旦渲染器进程 “完成” 渲染，它就会通过 IPC 将消息通知回浏览器进程（这是在所有页面中的 onload 事件都触发之后执行的）。此时，UI 线程会隐藏选项卡上的加载进度图标。&lt;/p&gt;
&lt;p&gt;这里的 “完成” 之所以加引号，因为客户端 JavaScript 仍然可以加载额外的资源，并在此之后呈现新的视图。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;渲染器进程—如何将html、css和js处理成可以与用户交互的网页&lt;/h3&gt;
&lt;p&gt;  渲染器进程的核心工作内容是将html、css和js处理成可以与用户交互的网页。&lt;/p&gt;
&lt;h4&gt;解析&lt;/h4&gt;
&lt;p&gt;  渲染器进程开始接收html数据后，主线程就开始处理html，将其处理成DOM&lt;/p&gt;
&lt;h4&gt;子资源加载&lt;/h4&gt;
&lt;p&gt;  为了加快资源加载速度，主线程会启用“预加载扫描”，发现有类似 img 或 link 这样的标签时，会由 HTML 解析器对该资源生成一个 Tokens，然后在浏览器进程中，通过网络或者本地缓存来加载资源。&lt;/p&gt;
&lt;p&gt;  一个完整的 Web 站点通常会包含图片、CSS 和 JS 等外部资源，这些文件都需要从网络或者本地缓存中加载。主线程可以在解析构建 DOM 的时候，将他们逐个请求。&lt;/p&gt;
&lt;h4&gt;JS可以阻止解析&lt;/h4&gt;
&lt;p&gt;  当 HTML 解析器遇到script 标签的时候，它会暂停解析 HTML 文档，然后对这个 JS 脚本进行加载、解析和执行。因为js脚本可以改变dom元素，因而HTML 解析器在重新解析 HTML 之前，必须等待 JS 脚本执行。&lt;/p&gt;
&lt;p&gt;  HTML 遇到 JS 脚本则暂停对 HTML 的解析，这并不是绝对的。script 标签中添加 async 或 defer 标记，然后浏览器会异步加载和运行此 JS 脚本，不会阻断解析。如果需要，也可以使用 JavaScript Modules，还可以通过 rel=“preload” 标签向浏览器明确标记此为重要的资源，将在页面加载完成之后被立刻使用，对于这类资源，它会在页面加载生命周期的早期，被优先加载。&lt;/p&gt;
&lt;h4&gt;样式渲染&lt;/h4&gt;
&lt;p&gt;  主线程解析css并添加渲染样式。即使不用css，每个dom节点存在默认的样式。&lt;/p&gt;
&lt;h4&gt;布局&lt;/h4&gt;
&lt;p&gt;  主线程遍历dom树并计算样式，然后创建layout树，在布局树中包含元素的x、y坐标和边框大小的信息。举个例子，如果某个元素设置了 display:none，则该元素将不会出现在布局树中，但是它会出现在 DOM 树中，而如果该元素被设置为 visibility:hidden 则它会存在于布局树中。类似的例子还有 p::before{content:“Hi!“}  这样的伪类，它会存在于布局树中，而不会存在于 DOM 树中。&lt;/p&gt;
&lt;h4&gt;绘制&lt;/h4&gt;
&lt;p&gt;  拥有 DOM、CSS 和 LayoutTree 仍然不足以渲染页面。假设你正在尝试重绘一幅画，你除了需要知道元素的大小、外观和位置之外，还需要知道它们的绘制顺序。例如z-index属性的设置，因而在这过程中，主线程遍历布局树，然后创建绘制记录。&lt;/p&gt;
&lt;h4&gt;更新渲染管道&lt;/h4&gt;
&lt;p&gt;  渲染管道（Rendering Pipeline）中最重要的任务，就是在每个步骤开始前，根据前一次操作的结果，来创建新的数据。例如，如果布局树中的某些内容发生更改，则需要为文档的受影响部分重新生成“绘制”顺序。&lt;/p&gt;
&lt;p&gt;  渲染管道（Rendering Pipeline）中最重要的任务，就是在每个步骤开始前，根据前一次操作的结果，来创建新的数据。例如，如果布局树中的某些内容发生变动，则需要为文档中受影响的部分，重新生成“绘制记录”。&lt;/p&gt;
&lt;h3&gt;合成&lt;/h3&gt;
&lt;p&gt;  现在浏览器知道页面的结构、元素样式、绘制顺序，要将这些元素转换为屏幕的像素，称为光栅化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;光栅化是将几何数据经过一系列变换后最终转换为像素，从而呈现在显示设备上的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;合成&lt;/h4&gt;
&lt;p&gt;  合成是一种将页面的各个元素进行分层，分别光栅化，并在合成器线程中以一个单独的线程合成新页面的技术。如果页面发生滚动，由于图层已经光栅化，因此它需要做的就是合成一个新帧。通过移动图层同时合成新帧，可以以相同的方式实现动画。&lt;/p&gt;
&lt;h4&gt;分层&lt;/h4&gt;
&lt;p&gt;  为了确定每个元素所在的层，主线程遍历布局树以创建层树（Layer Tree)&lt;/p&gt;
&lt;h4&gt;光栅和合成，脱离主线程&lt;/h4&gt;
&lt;p&gt;  一旦创建了层树并确定了绘制顺序，主线程就会将该信息提交给合成器线程。合成器线程会光栅化每个图层，一个图层可能想一个完整的页面那么大，因此合成器线程将他们分成图块，并将每个图块发送到光栅线程。光栅线程格式化每个元素，并将他们存储在 GPU 内存中。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://developers.google.com/web/updates/images/inside-browser/part3/raster.png&quot; alt=&quot;hw-os-app&quot;&gt;&lt;/p&gt;
&lt;p&gt;  合成器线程可以优先考虑不同的光栅线程，以便 ViewPort（或附近）的元素可以被优先光栅化。图层还具有多个不同分辨率的倾斜度，以便对内容的放大等操作。&lt;/p&gt;
&lt;p&gt;  一旦元素被光栅化，合成器线程会收集被称为 “绘制矩形（Draw Quads）” 的信息，用以创建一个合成帧（Compositor Frame）。&lt;/p&gt;
&lt;p&gt;  然后通过 IPC 将合成帧提交给浏览器进程。此时，可以从 UI 线程添加另一个合成帧用于浏览器的 UI 更新，或者从其他渲染器进程中添加扩展。这些合成帧被发送到 GPU 中，用以在屏幕上显示。如果触发滚动事件，合成器线程会创建另一个合成帧发送到 GPU。&lt;/p&gt;
&lt;p&gt;  合成（Compositor）的好处，是它可以在不影响主线程的情况下完成。合成器线程不需要等待样式计算或者 JS 脚本执行，这就是为什么 “仅合成动画” 被认为是平滑性能的最佳选择。如果需要再次计算不会或者重新绘制，则必须涉及到主线程。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[通过gatsby搭建自己的博客]]></title><description><![CDATA[如何通过gatsby搭建博客 下载gatsby脚手架 npm i gatsby-cli -g 新建一个博客目录  gatsby new blog 运行博客  gatsby develop 在github page上关联gatsby项目 添加项目原地址 git add remote…]]></description><link>https://chinleyhuang.ink/build-a-blog-by-gatsby/</link><guid isPermaLink="false">https://chinleyhuang.ink/build-a-blog-by-gatsby/</guid><pubDate>Tue, 27 Apr 2021 23:46:37 GMT</pubDate><content:encoded>&lt;h3&gt;如何通过gatsby搭建博客&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;下载gatsby脚手架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm i gatsby-cli -g&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个博客目录 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gatsby new blog&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行博客 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gatsby develop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在github page上关联gatsby项目&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加项目原地址 git add remote xxxxx&lt;/li&gt;
&lt;li&gt;如有修改 git add、git push&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打包静态资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过gh-pages打包，npm install gh-pages —save-dev&lt;/li&gt;
&lt;li&gt;在packag.json中添加脚本：gatsby build —prefix-paths &amp;#x26;&amp;#x26; gh-pages -d public -b public，gh-pages就会将文件打包到public目录，并提交到分支public&lt;/li&gt;
&lt;li&gt;在github里将项目pages的sources设置为public分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;打包资源成功后，在githubpage的页面就能看到样式啦&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何关联自己的域名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在自己域名下配置dns A类型, 记录值为githubpage ip 185.199.108.153&lt;/li&gt;
&lt;li&gt;添加CNAME dns, 记录值为你的githupage域名&lt;/li&gt;
&lt;li&gt;githupage项目下设置custom domain为自己的域名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;npm i一直停留在sharp-libvips&lt;/h3&gt;
&lt;p&gt;  一些包被墙了，打开vpn也下载不了,需要绑定host&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;192.30.255.112	gist.github.com
192.30.255.112	github.com
192.30.255.112	www.github.com
151.101.56.133	avatars0.githubusercontent.com
151.101.56.133	avatars1.githubusercontent.com
151.101.56.133	avatars2.githubusercontent.com
151.101.56.133	avatars3.githubusercontent.com
151.101.56.133	avatars4.githubusercontent.com
151.101.56.133	avatars5.githubusercontent.com
151.101.56.133	avatars6.githubusercontent.com
151.101.56.133	avatars7.githubusercontent.com
151.101.56.133	avatars8.githubusercontent.com
151.101.56.133	camo.githubusercontent.com
151.101.56.133	cloud.githubusercontent.com
151.101.56.133	gist.githubusercontent.com
151.101.56.133	marketplace-screenshots.githubusercontent.com
151.101.56.133	raw.githubusercontent.com
151.101.56.133	repository-images.githubusercontent.com
151.101.56.133	user-images.githubusercontent.com&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;
&lt;h3&gt;gatsby build WorkerError: failed to process image&lt;/h3&gt;
&lt;p&gt;  删除node_modules再重新npm i，无果，重新下载gatsby-cli，再搭建新的项目&lt;/p&gt;</content:encoded></item></channel></rss>